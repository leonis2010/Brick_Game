./brick_game/common/common.c

#include "../tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
#else
void waiting_Enter() {
  int ch;
  while ((ch = getch()) != KEY_ENTER && ch != '\n') {
  }
}
#endif

./brick_game/common/high_score/high_score.h

#ifndef HIGH_SCORE_H
#define HIGH_SCORE_H
#include <stdio.h>
#include <stdlib.h>
/**
 * @brief Имя файла для сохранения рекорда.
 */
#define HIGH_SCORE_FILENAME "high_score.txt"

int load_high_score(int game_type);
void save_high_score(int score, int game_type);

#endif  // HIGH_SCORE_H


./brick_game/common/high_score/load_high_score.c

#include "high_score.h"

int load_high_score(int flag) {
  char filename[256];
  snprintf(filename, sizeof(filename), "%s/bin/%s", getenv("HOME"),
           HIGH_SCORE_FILENAME);
  FILE *file = fopen(filename, "r");
  if (file == NULL) {
    return 0;
  }

  int high_score = 0;
  int current_line = 0;

  // Читаем файл построчно
  // feof Возвращает ненулевое значение (истина),
  // если указатель на файл (file) достиг конца файла.
  while (!feof(file)) {
    int score;
    if (fscanf(file, "%d", &score) == 1) {
      current_line++;
      if (current_line == flag) {
        high_score = score;
        break;
      }
    } else {
      break;
    }
  }

  fclose(file);
  return high_score;
}

./brick_game/common/high_score/save_high_score.c

#include "high_score.h"
void save_high_score(int high_score, int flag) {
  char filename[256];
  snprintf(filename, sizeof(filename), "%s/bin/%s", getenv("HOME"),
           HIGH_SCORE_FILENAME);

  FILE *file = fopen(filename, "r");
  int scores[2] = {0, 0};
  if (file != NULL) {
    if (fscanf(file, "%d", &scores[0]) != 1) {
      scores[0] = 0;  // Первая строка для тетриса
    }
    if (fscanf(file, "%d", &scores[1]) != 1) {
      scores[1] = 0;  // Вторая строка для змейки
    }
    // fscanf(file, "%d", &scores[0]);
    // fscanf(file, "%d", &scores[1]);
    fclose(file);
  }

  if (flag == 1) {
    scores[0] = high_score;
  } else if (flag == 2) {
    scores[1] = high_score;
  }

  file = fopen(filename, "w");
  if (file == NULL) {
    fprintf(stderr, "Failed to open file for writing: %s\n", filename);
    return;
  }
  fprintf(file, "%d\n%d", scores[0], scores[1]);
  fclose(file);
}

./brick_game/snake/cli_controller/s21_cli_snake.h

#ifndef S21_SNAKE_H
#define S21_SNAKE_H

#include <algorithm>
#include <deque>
#include <string>
#include <utility>

namespace s21 {

enum Direction { UP, DOWN, LEFT, RIGHT };

class SnakeModel;
class SnakeView;
class SnakeController;

}  // namespace s21

#endif  // S21_SNAKE_H

./brick_game/snake/cli_controller/snake_controller.cpp

#include "snake_controller.h"

#include <sys/time.h>
#include <unistd.h>

#include <iostream>

#include "../../../gui/cli/snake/snake_view.h"
#include "../model/snake_model.h"

namespace s21 {
SnakeController::SnakeController(SnakeModel& model, SnakeView& view)
    : model_(model), view_(view), is_boost_key_down_(false) {}

void SnakeController::HandleInput(int ch) {
  if (ch == 27) {
    model_.TogglePause();
    return;
  }
  if (model_.IsPause()) return;

  switch (ch) {
    case KEY_UP:
      if (model_.GetDirection() != DOWN) model_.SetDirection(UP);
      break;
    case KEY_DOWN:
      if (model_.GetDirection() != UP) model_.SetDirection(DOWN);
      break;
    case KEY_LEFT:
      if (model_.GetDirection() != RIGHT) model_.SetDirection(LEFT);
      break;
    case KEY_RIGHT:
      if (model_.GetDirection() != LEFT) model_.SetDirection(RIGHT);
      break;
    case ' ':
      is_boost_key_down_ = true;
      model_.SetBoost(true);
      break;
    case 'q':
    case 'Q':
      model_.SetGameOver(true);
      break;
    default:
      is_boost_key_down_ = false;
      break;
  }
}

void SnakeController::sleeping_game() {
  int delay_ms = model_.GetDelay();

  struct timeval start_time;
  gettimeofday(&start_time, NULL);

  // Опрос клавиатуры во время ожидания
  while (true) {
    int ch = getch();
    if (ch != ERR) {
      HandleInput(ch);
    }

    // Вычисляем прошедшее время
    struct timeval now;
    gettimeofday(&now, NULL);
    long elapsed_ms = (now.tv_sec - start_time.tv_sec) * 1000 +
                      (now.tv_usec - start_time.tv_usec) / 1000;

    if (elapsed_ms >= delay_ms) break;
    // короткая пауза
    usleep(1000);
  }
}
void SnakeController::checkingBoost() {
  // После завершения задержки проверяем: удерживается ли пробел
  if (!is_boost_key_down_) {
    model_.SetBoost(false);
    is_boost_key_down_ = false;
  }
}

void SnakeController::Update() {
  sleeping_game();
  checkingBoost();
  model_.Move();
  view_.Draw(model_);
}

bool SnakeController::IsGameOver() const { return model_.IsGameOver(); }

}  // namespace s21


./brick_game/snake/cli_controller/snake_controller.h

#ifndef S21_SNAKE_CONTROLLER_H
#define S21_SNAKE_CONTROLLER_H

#include "s21_cli_snake.h"

namespace s21 {

class SnakeController {
 public:
  SnakeController(SnakeModel& model, SnakeView& view);
  void HandleInput(int ch);
  void Update();
  bool IsGameOver() const;
  void sleeping_game();
  void checkingBoost();

 private:
  SnakeModel& model_;
  SnakeView& view_;
  bool is_boost_key_down_;
};

}  // namespace s21

#endif  // S21_SNAKE_CONTROLLER_H


./brick_game/snake/cli_controller/snake_main.cpp

#include <unistd.h>

#include "../../../gui/cli/snake/snake_view.h"
#include "../model/snake_model.h"
#include "snake_controller.h"
#ifdef TEST_MODE
#else
extern "C" {
#include "../../tetris/model/s21_tetris_cli.h"  // Для внешних функций
void snake_main() {
  noecho();
  cbreak();
  initialization_of_colors();
  WINDOW *win_game, *win_next_figure, *win_score_level, *win_high_score;
  if (cli_create_frames_for_game(&win_game, &win_next_figure, &win_score_level,
                                 &win_high_score) != 0) {
    endwin();
    return;
  }

  s21::SnakeModel model;
  s21::SnakeView view(win_game, win_next_figure, win_score_level,
                      win_high_score);
  s21::SnakeController controller(model, view);
  nodelay(stdscr, FALSE);
  keypad(stdscr, TRUE);
  curs_set(0);
  refresh();
  display_welcome_screen(model.GetHighScore(), win_game, win_next_figure,
                         win_score_level, win_high_score, 2);
  int ch;
  waiting_Enter();
  nodelay(stdscr, TRUE);
  while (!controller.IsGameOver()) {
    ch = getch();
    controller.HandleInput(ch);
    if (model.IsPause()) {
      view.DisplayPause();
      continue;
    }
    controller.Update();
  }

  save_high_score(model.GetHighScore(), 2);
  view.DisplayGameOver(model);
  nodelay(stdscr, FALSE);
  getch();

  delwin(win_game);
  delwin(win_next_figure);
  delwin(win_score_level);
  delwin(win_high_score);
  endwin();
}
}
#endif


./brick_game/snake/model/snake_model.cpp

#include "snake_model.h"

#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <fstream>
extern "C" {
#include "../../common/high_score/high_score.h"
}

namespace s21 {
const std::string SnakeModel::HIGH_SCORE_FILE = "snake_high_score.txt";
SnakeModel::SnakeModel()
    : direction_(DOWN),
      game_over_(false),
      win_(false),
      score_(0),
      level_(1),
      speed_delay_(SPEED_DELAY),
      boost_(false),
      start_screen_(true) {
  high_score_ = load_high_score(2);  // Загружаем рекорд из Си
  int center_x = WIDTH / 2;
  int start_y = HEIGHT / 3;
  for (int i = 3; i >= 0; --i) {
    snake_.emplace_back(start_y + i, center_x);
  }
  GenerateFood();
}

void SnakeModel::Move() {
  std::pair<int, int> head = snake_.front();
  switch (direction_) {
    case UP:
      head.first--;
      break;
    case DOWN:
      head.first++;
      break;
    case LEFT:
      head.second--;
      break;
    case RIGHT:
      head.second++;
      break;
  }
  if (head.first < 0 || head.first >= HEIGHT || head.second < 0 ||
      head.second >= WIDTH ||
      std::find(snake_.begin(), snake_.end(), head) != snake_.end()) {
    game_over_ = true;
    win_ = false;
    return;
  }

  snake_.push_front(head);

  if (head == food_) {
    score_ += SCORE;
    if (score_ > high_score_) high_score_ = score_;
    if (score_ >= 200) {
      win_ = true;
      game_over_ = true;
    }
    UpdateLevel();
    GenerateFood();
  } else {
    snake_.pop_back();
  }
}

bool SnakeModel::IsStartScreen() const { return start_screen_; }
void SnakeModel::SetStartScreen(bool state) { start_screen_ = state; }
bool SnakeModel::IsWin() const { return win_; }
void SnakeModel::SetDirection(Direction dir) { direction_ = dir; }
Direction SnakeModel::GetDirection() const { return direction_; }
void SnakeModel::SetGameOver(bool game_over) { game_over_ = game_over; }
bool SnakeModel::IsGameOver() const { return game_over_; }
bool SnakeModel::IsPause() const { return pause_; }
void SnakeModel::TogglePause() { pause_ = !pause_; }
int SnakeModel::GetScore() const { return score_; }
int SnakeModel::GetLevel() const { return level_; }
int SnakeModel::GetHighScore() const { return high_score_; }

const std::deque<std::pair<int, int>>& SnakeModel::GetSnake() const {
  return snake_;
}

const std::pair<int, int>& SnakeModel::GetFood() const { return food_; }
void SnakeModel::SetBoost(bool isActive) { boost_ = isActive; }

int SnakeModel::GetDelay() const {
  return boost_ ? speed_delay_ / 2.5 : speed_delay_;
}

void SnakeModel::UpdateLevel() {
  level_ = std::min(10, score_ / 5 + 1);
  speed_delay_ = SPEED_DELAY - (level_ - 1) * 15;
}

void SnakeModel::GenerateFood() {
  int x, y;
  do {
    x = rand() % WIDTH;
    y = rand() % HEIGHT;
  } while (std::find(snake_.begin(), snake_.end(), std::make_pair(y, x)) !=
           snake_.end());
  food_ = std::make_pair(y, x);
}

void SnakeModel::Reset() {
  snake_.clear();
  // Устанавливаем начальную позицию
  int center_x = WIDTH / 2;
  int start_y = HEIGHT / 3;
  for (int i = 3; i >= 0; --i) {
    snake_.emplace_back(start_y + i, center_x);
  }

  direction_ = DOWN;
  score_ = 0;
  level_ = 1;
  speed_delay_ = SPEED_DELAY;
  boost_ = false;
  game_over_ = false;

  // Новое яблоко
  GenerateFood();
  UpdateLevel();
}

// Только для тестов следующие функции
void SnakeModel::PlaceFoodInFront() {
  auto head = snake_.front();
  switch (direction_) {
    case UP:
      food_ = std::make_pair(head.first - 1, head.second);
      break;
    case DOWN:
      food_ = std::make_pair(head.first + 1, head.second);
      break;
    case LEFT:
      food_ = std::make_pair(head.first, head.second - 1);
      break;
    case RIGHT:
      food_ = std::make_pair(head.first, head.second + 1);
      break;
  }
}
void SnakeModel::FeedSnake(int bites) {
  for (int i = 0; i < bites; ++i) {
    PlaceFoodInFront();
    Move();
  }
}

bool SnakeModel::GetBoost() const { return boost_; }

}  // namespace s21


./brick_game/snake/model/snake_model.h

#ifndef S21_SNAKE_MODEL_H
#define S21_SNAKE_MODEL_H
#include "../cli_controller/s21_cli_snake.h"

namespace s21 {

inline constexpr int WIDTH = 10;
inline constexpr int HEIGHT = 20;
inline constexpr int SPEED_DELAY = 400;
inline constexpr int SCORE = 1;

class SnakeModel {
 public:
  SnakeModel();
  void Move();
  void SetDirection(Direction dir);
  Direction GetDirection() const;
  void SetGameOver(bool game_over);
  bool IsGameOver() const;
  bool IsPause() const;
  void TogglePause();
  int GetScore() const;
  int GetLevel() const;
  int GetHighScore() const;
  const std::deque<std::pair<int, int>>& GetSnake() const;
  const std::pair<int, int>& GetFood() const;
  void SetBoost(bool boost);
  int GetDelay() const;
  void Reset();
  bool IsWin() const;
  bool IsStartScreen() const;
  void SetStartScreen(bool state);
  void PlaceFoodInFront();
  void FeedSnake(int bites);
  bool GetBoost() const;

 private:
  std::deque<std::pair<int, int>> snake_;
  std::pair<int, int> food_;
  Direction direction_;
  bool game_over_;
  bool win_;
  int score_;
  int high_score_;
  int level_;
  int speed_delay_;
  bool boost_;
  bool pause_ = false;
  static const std::string HIGH_SCORE_FILE;
  bool start_screen_;

  void UpdateLevel();
  void GenerateFood();
};

}  // namespace s21

#endif  // S21_SNAKE_MODEL_H


./brick_game/snake/qt_controller/qt_snake_controller.cpp

#include "qt_snake_controller.h"

#include "qtimer.h"

namespace s21 {

QtSnakeController::QtSnakeController(SnakeModel& model, QtSnakeView& view)
    : QObject(nullptr), model_(model), view_(view) {
  // Основные соединения
  connect(&timer_, &QTimer::timeout, this, &QtSnakeController::onTimeout);
  connect(&view_, &QtSnakeView::keyPressed, this,
          &QtSnakeController::handleKeyPress);
  connect(&view_, &QtSnakeView::keyReleased, this,
          &QtSnakeController::handleKeyRelease);

  model_.SetStartScreen(true);
  timer_.stop();

  if (!model_.IsStartScreen()) {
    timer_.start(model_.GetDelay());
  }
}

SnakeDrawData QtSnakeController::get_data_from_model(SnakeModel& model) {
  SnakeDrawData data;
  data.snake = model.GetSnake();
  data.food = model.GetFood();
  data.score = model.GetScore();
  data.paused = model.IsPause();
  data.game_over = model_.IsGameOver();
  data.win = model_.IsWin();
  data.high_score = model_.GetHighScore();
  data.level = model_.GetLevel();
  data.start_screen = model_.IsStartScreen();
  return data;
}

void QtSnakeController::onTimeout() {  // сердце игры
  model_.Move();
  refresh_timer();
  view_.draw(get_data_from_model(model_));
  if (model_.IsGameOver()) {
    timer_.stop();
    save_high_score(model_.GetHighScore(), 2);
  }
}

void QtSnakeController::handleKeyPress(QKeyEvent* event) {
  qDebug() << "Key pressed:" << event->key()
           << "Pause state before:" << model_.IsPause();
  if (model_.IsStartScreen() || model_.IsGameOver()) {
    if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
      startGame();
    } else if (event->key() == Qt::Key_Escape) {
      emit requestReturnToMenu();
    }
    return;
  }

  // Логика во время игры
  if (event->key() == Qt::Key_Escape) {
    qDebug() << "Escape processing started";
    model_.TogglePause();
    qDebug() << "Pause state after toggle:" << model_.IsPause();
    if (model_.IsPause()) {
      view_.draw(get_data_from_model(model_));
      timer_.stop();
      qDebug() << "Timer stopped";
    } else {
      refresh_timer();
      qDebug() << "Timer restarted";
    }
    return;
  }

  if (model_.IsPause()) {
    return;
  }

  switch (event->key()) {
    case Qt::Key_Up:
      if (model_.GetDirection() != DOWN) model_.SetDirection(UP);
      break;
    case Qt::Key_Down:
      if (model_.GetDirection() != UP) model_.SetDirection(DOWN);
      break;
    case Qt::Key_Left:
      if (model_.GetDirection() != RIGHT) model_.SetDirection(LEFT);
      break;
    case Qt::Key_Right:
      if (model_.GetDirection() != LEFT) model_.SetDirection(RIGHT);
      break;
    case Qt::Key_Space:
      model_.SetBoost(true);
      break;
    default:
      model_.SetBoost(false);
      break;
  }
  view_.update();
}

// Отпускание клавишы
void QtSnakeController::handleKeyRelease(QKeyEvent* event) {
  if (event->key() == Qt::Key_Space) {
    model_.SetBoost(false);
  }
}

void QtSnakeController::startGame() {
  model_.Reset();
  model_.SetStartScreen(false);
  refresh_timer();
}

void QtSnakeController::refresh_timer() {
  if (timer_.isActive()) {
    timer_.stop();
  }
  timer_.start(model_.GetDelay());

  // qDebug() << "SPEED_DELAY: " << model_.GetDelay();  // дебаг
}

}  // namespace s21


./brick_game/snake/qt_controller/qt_snake_controller.h

#ifndef QT_SNAKE_CONTROLLER_H
#define QT_SNAKE_CONTROLLER_H
#include <QKeyEvent>
#include <QTimer>

#include "../model/snake_model.h"
#include "qt_snake_view.h"
extern "C" {
#include "../../common/high_score/high_score.h"
}
namespace s21 {

class QtSnakeController : public QObject {
  Q_OBJECT
 public:
  QtSnakeController(SnakeModel& model, QtSnakeView& view);
  void UpdateTimer();
  void refresh_timer();
  SnakeDrawData get_data_from_model(SnakeModel& model);
  void handleKeyPress(QKeyEvent* event);
  void handleKeyRelease(QKeyEvent* event);
  void startGame();

 signals:
  void requestStartGame();
  void requestReturnToMenu();
  void gameStateChanged();

 private slots:
  void onTimeout();

 private:
  SnakeModel& model_;
  QtSnakeView& view_;
  QTimer timer_;
};

}  // namespace s21

#endif  // QT_SNAKE_CONTROLLER_H


./brick_game/snake/qt_controller/s21_qt_snake.h

#ifndef QT_S21_SNAKE_H
#define QT_S21_SNAKE_H
#include <deque>  //debug

#include "../model/snake_model.h"
namespace s21 {

class QtSnakeView;
class QtSnakeController;

}  // namespace s21

#endif  // QT_S21_SNAKE_H


./brick_game/tetris/controller/buttons_reaction.c

#include "../model/s21_tetris_cli.h"
void buttons_reaction(int ch, Tetris_Game *tetris_game) {
  switch (ch) {
    case ERR:
      tetris_game->player->action = PLAYER_NOP;
      break;
      // 32 - Пробел поворот фигуры
    case 32:
      tetris_game->player->action = PLAYER_UP;
      break;
    case 's':
    case KEY_DOWN:
      tetris_game->player->action = PLAYER_DOWN;
      break;
    case 'a':
    case KEY_LEFT:
      tetris_game->player->action = PLAYER_LEFT;
      break;
    case 'd':
    case KEY_RIGHT:
      tetris_game->player->action = PLAYER_RIGHT;
      break;
      // 81 - 'q'
      // 113 - 'Q'
    case 81:
    case 113:
      tetris_game->player->action = PLAYER_QUIT;
      tetris_game->playing = GAME_OVER;
      break;
      // 27 - ESC
    case 27:
      tetris_game->player->action = PLAYER_PAUSE;
      break;
    default:
      tetris_game->player->action = PLAYER_NOP;
      break;
  }
}


./brick_game/tetris/controller/game_over.c

#include "../model/s21_tetris_cli.h"

void game_over(Tetris_Game* tetris_game, WINDOW* win_game,
               int (*input_func)(void)) {
  curs_set(0);
  cli_game_over(tetris_game, win_game);
  int character;

  int enter = 10;
  int esc = 27;
  while ((character = input_func()) != 88) {
    if (character == esc) {
      tetris_game->playing = GAME_OVER;
      break;
    }
    if (character == enter) {
      reset_game(tetris_game);
      break;
    }
  }
}
#ifdef TEST_MODE
// Заглушка для тестирования
int input_func(void) {
  return 10;  // Возвращаем фиксированное значение, например, Enter
}
#else
int input_func(void) { return getch(); }
#endif

./brick_game/tetris/controller/pause_processing.c


#include "../model/s21_tetris_cli.h"

void pause_processing(Tetris_Game* tetris_game, bool* paused,
                      WINDOW* win_game) {
  if (tetris_game->player->action == PLAYER_PAUSE) {
    *paused = !(*paused);
    if (*paused) {
      cli_print_pause(win_game);
    }
  }
  curs_set(0);
}

./brick_game/tetris/controller/stub_tetris.c

#include "../../common/high_score/high_score.h"
#include "../model/s21_tetris_cli.h"
#ifdef TEST_MODE
#else

void tetris_main() {
  printf(
      "\n\n\n                       Я запустился!!\nНо у вас слишком маленький "
      "экранчик, я не помещаюсь :(\n\n\n");
  int error = 0;
  srand(time(NULL));
  struct timespec sp_start, sp_end, ts2 = {0, 0};

  // initscr();
  start_color();
  cbreak();  // не перехватывать нажатия клавиш
  setenv("TERM", "xterm-256color", 1);
  noecho();              // не печатать нажатые клавиши
  keypad(stdscr, TRUE);  // для работы стрелок клавиатуры
  nodelay(stdscr, TRUE);   // не ждать нажатия клавиши
  scrollok(stdscr, TRUE);  // отключение прокрутки окна

  int field_width = 10;
  int field_height = 20;
  int figures_size = 4;
  int number_of_figures = 7;
  Tetris_Game *tetris_game =
      create_memory_game(field_width, field_height, figures_size,
                         number_of_figures, figures_template);
  Tetris_Player player;
  player.action = PLAYER_NOP;
  tetris_game->player = &player;
  int flag_one_for_tetris = 1;
  int high_score = load_high_score(flag_one_for_tetris);
  tetris_game->high_score = high_score;
  drop_new_figure(tetris_game);
  WINDOW *win_game = NULL;
  WINDOW *win_next_figure = NULL;
  WINDOW *win_score_level = NULL;
  WINDOW *win_high_score = NULL;
  error = cli_create_frames_for_game(&win_game, &win_next_figure,
                                     &win_score_level, &win_high_score);
  if (error) {
    endwin();
    return;
  }
  display_welcome_screen(high_score, win_game, win_next_figure, win_score_level,
                         win_high_score, 1);
  waiting_Enter();
  int button = 0;
  bool paused = false;

  while (tetris_game->playing != GAME_OVER) {
    clock_gettime(CLOCK_MONOTONIC, &sp_start);
    button = getch();
    buttons_reaction(button, tetris_game);
    pause_processing(tetris_game, &paused, win_game);
    if (paused) continue;
    bool game_state_changed = calculate(tetris_game);
    if (game_state_changed) {
      print_high_score(tetris_game);
      cli_print_game(tetris_game, win_game, win_next_figure, win_score_level,
                     win_high_score);
      if (tetris_game->playing == GAME_OVER) {
        game_over(tetris_game, win_game, input_func);
        save_high_score(tetris_game->high_score, flag_one_for_tetris);
      }
    }

    clock_gettime(CLOCK_MONOTONIC, &sp_end);
    speed_from_level(*tetris_game, sp_start, sp_end, &ts2);
  }
  delwin(win_game);
  delwin(win_next_figure);
  delwin(win_score_level);
  delwin(win_high_score);
  endwin();
  free_memory_game(tetris_game);
  return;
}
#endif

./brick_game/tetris/model/calculate.c

#include "s21_tetris_game_core.h"

bool calculate(Tetris_Game* tetris_game) {
  bool state_changed = false;
  if (tetris_game->ticks_left <= 0) {
    tetris_game->ticks_left = tetris_game->ticks;
    moveFigureDown(tetris_game);
    if (collision(tetris_game)) {
      moveFigureUp(tetris_game);
      plant_figure(tetris_game);
      int lines = erasse_lines(tetris_game);
      counting_score_and_level(tetris_game, lines);
      drop_new_figure(tetris_game);
      if (collision(tetris_game)) {
        tetris_game->playing = GAME_OVER;
        state_changed = true;  // Произошло изменение состояния
      }
      state_changed = true;  // Произошло изменение состояния
    }
    state_changed = true;  // Произошло изменение состояния
  }
  execute_player_command(tetris_game->player->action, tetris_game,
                         &state_changed);
  tetris_game->ticks_left--;
  return state_changed;
}

void counting_score_and_level(Tetris_Game* tetris_game, int lines) {
  tetris_game->score += (lines == 1   ? score_for_1_line
                         : lines == 2 ? 300
                         : lines == 3 ? 700
                         : lines == 4 ? 1500
                                      : 0);
  tetris_game->level =
      tetris_game->level >= 10 ? 10 : tetris_game->score / 600 + 1;
}

void execute_player_command(int action, Tetris_Game* tetris_game,
                            bool* state_changed) {
  switch (action) {
    case PLAYER_RIGHT:
      *state_changed = true;  // Произошло изменение состояния
      moveFigureRight(tetris_game);
      if (collision(tetris_game)) {
        moveFigureLeft(tetris_game);
      }
      break;
    case PLAYER_LEFT:
      *state_changed = true;  // Произошло изменение состояния
      moveFigureLeft(tetris_game);
      if (collision(tetris_game)) {
        moveFigureRight(tetris_game);
      }
      break;
    case PLAYER_DOWN:
      *state_changed = true;  // Произошло изменение состояния
      moveFigureDown(tetris_game);
      if (collision(tetris_game)) {
        moveFigureUp(tetris_game);
      }
      break;
    case PLAYER_UP: {
      *state_changed = true;  // Произошло изменение состояния
      Tetris_Figure* t = rotTetFigure(tetris_game);
      Tetris_Figure* told = tetris_game->figure;
      tetris_game->figure = t;
      if (collision(tetris_game)) {
        tetris_game->figure = told;
        free_tetris_figure(t);
        t = NULL;
      } else {
        free_tetris_figure(told);
        told = NULL;
      }
    } break;
    case PLAYER_QUIT:
      *state_changed = true;  // Произошло изменение состояния
      tetris_game->playing = GAME_OVER;
      break;
    case PLAYER_PAUSE:
      *state_changed = true;  // Произошло изменение состояния
      tetris_game->playing = PLAYING;
      break;
    case PLAYER_NOP:
    default:
      break;
  }
}


./brick_game/tetris/model/collision.c

#include "s21_tetris_game_core.h"

int collision(Tetris_Game* tetris_game) {
  int output = 0;
  Tetris_Figure* t = tetris_game->figure;
  Tetris_Field* tf = tetris_game->field;
  for (int i = 0; i < t->size; i++) {
    for (int j = 0; j < t->size; j++) {
      if (t->blocks[i * t->size + j].b != 0) {
        int fx = t->x + j;
        int fy = t->y + i;
        if (fx < 0 || fx >= tf->width || fy < 0 || fy >= tf->height ||
            tf->blocks[fy * tf->width + fx].b != 0) {
          output = 1;
          break;
        }
      }
    }
    if (output == 1) break;
  }
  return output;
}

./brick_game/tetris/model/creating_memory_game_objects.c

#include "s21_tetris_game_core.h"

Tetris_Game* create_memory_game(int field_width, int field_height,
                                int figures_size, int number_of_figures,
                                const Tetris_Block* figures_template) {
  Tetris_Game* tetris_game = (Tetris_Game*)malloc(sizeof(Tetris_Game));
  tetris_game->field = create_memory_field(field_width, field_height);
  tetris_game->figure = NULL;
  tetris_game->next_figure = NULL;
  tetris_game->figures_template = create_memory_figures_template(
      number_of_figures, figures_size, figures_template);
  tetris_game->player = NULL;
  tetris_game->ticks = TET_TICK_START;
  tetris_game->ticks_left = TET_TICK_START;
  tetris_game->playing = PLAYING;
  tetris_game->score = 0;
  tetris_game->level = 1;
  tetris_game->high_score = 0;
  tetris_game->figure_bag = NULL;
  tetris_game->bag_index = 0;
  return tetris_game;
}

Tetris_Field* create_memory_field(int width, int height) {
  Tetris_Field* tetris_field = (Tetris_Field*)malloc(sizeof(Tetris_Field));
  tetris_field->width = width;
  tetris_field->height = height;
  tetris_field->blocks =
      (Tetris_Block*)malloc(sizeof(Tetris_Block) * width * height);
  if (tetris_field->blocks == NULL) {
    printf("Memory error\n");
    exit(1);
  }
  for (int i = 0; i < width * height; i++) {
    tetris_field->blocks[i].b = 0;
  }
  return tetris_field;
}

Tetris_Figures_Template* create_memory_figures_template(
    int number_of_figures, int figures_size,
    const Tetris_Block* figures_template) {
  Tetris_Figures_Template* tetris_figures_template =
      (Tetris_Figures_Template*)malloc(sizeof(Tetris_Figures_Template));
  if (tetris_figures_template == NULL) {
    printf("Memory error\n");
    exit(1);
  }
  tetris_figures_template->number_of_figures = number_of_figures;
  tetris_figures_template->size = figures_size;
  tetris_figures_template->blocks = figures_template;
  return tetris_figures_template;
}

Tetris_Figure* create_memory_figure(Tetris_Game* tetris_game) {
  Tetris_Figure* tetris_figure = (Tetris_Figure*)malloc(sizeof(Tetris_Figure));
  tetris_figure->x = 959 - 959;
  tetris_figure->y = 0;
  tetris_figure->size = tetris_game->figures_template->size;
  tetris_figure->blocks = (Tetris_Block*)malloc(
      sizeof(Tetris_Block) * tetris_figure->size * tetris_figure->size);
  if (tetris_figure->blocks == NULL) {
    printf("Memory error\n");
    exit(1);
  }
  for (int i = 0; i < tetris_figure->size * tetris_figure->size; i++) {
    tetris_figure->blocks[i].b = 0;
  }
  return tetris_figure;
}

./brick_game/tetris/model/drop_new_figure.c

#include "s21_tetris_game_core.h"

Tetris_Figure* get_next_figure(Tetris_Game* tetris_game);
Tetris_Figure* create_figure_from_template(Tetris_Game* tetris_game, int fnum);
int* create_figure_bag(int count);
void shuffle_figures(int* bag, int count);

void drop_new_figure(Tetris_Game* tetris_game) {
  if (tetris_game->next_figure == NULL) {
    tetris_game->next_figure = get_next_figure(tetris_game);
  }
  free_tetris_figure(tetris_game->figure);
  tetris_game->figure = tetris_game->next_figure;
  tetris_game->next_figure = get_next_figure(tetris_game);
}

Tetris_Figure* get_next_figure(Tetris_Game* tetris_game) {
  if (tetris_game->figure_bag == NULL ||
      tetris_game->bag_index >=
          tetris_game->figures_template->number_of_figures) {
    free_figure_bag(tetris_game->figure_bag);
    tetris_game->figure_bag =
        create_figure_bag(tetris_game->figures_template->number_of_figures);
    tetris_game->bag_index = 0;
  }
  int fnum = tetris_game->figure_bag[tetris_game->bag_index++];
  return create_figure_from_template(tetris_game, fnum);
}

int* create_figure_bag(int count) {
  int* bag = (int*)malloc(sizeof(int) * count);
  for (int i = 0; i < count; i++) {
    bag[i] = i;
  }
  shuffle_figures(bag, count);
  return bag;
}

void shuffle_figures(int* bag, int count) {
  for (int i = count - 1; i > 0; i--) {
    int j = rand() % (i + 1);
    int temp = bag[i];
    bag[i] = bag[j];
    bag[j] = temp;
  }
}

Tetris_Figure* create_figure_from_template(Tetris_Game* tetris_game, int fnum) {
  Tetris_Figure* tetris_figure = create_memory_figure(tetris_game);
  tetris_figure->x = tetris_game->field->width / 2 - tetris_figure->size / 2;
  tetris_figure->y = 0;
  // Устанавливаем цветовую пару в зависимости от индекса фигуры
  tetris_figure->color_pair = fnum + 1;
  for (int i = 0; i < tetris_figure->size; i++) {
    for (int j = 0; j < tetris_figure->size; j++) {
      tetris_figure->blocks[i * tetris_figure->size + j].b =
          tetris_game->figures_template
              ->blocks[fnum * tetris_figure->size * tetris_figure->size +
                       i * tetris_figure->size + j]
              .b;
    }
  }
  return tetris_figure;
}


./brick_game/tetris/model/free_memory/free_figure_bag.c

#include "../s21_tetris_game_core.h"

void free_figure_bag(int* bag) {
  if (bag) {
    free(bag);
  }
}

./brick_game/tetris/model/free_memory/free_memory_game.c

#include "../s21_tetris_game_core.h"

void free_memory_game(Tetris_Game* tetris_game) {
  if (tetris_game) {
    free_tetris_figure(tetris_game->figure);
    free_tetris_figure(tetris_game->next_figure);
    free_figure_bag(tetris_game->figure_bag);
    free_tetris_field(tetris_game->field);
    free_tetris_figures_template(tetris_game->figures_template);
    free(tetris_game);
  }
}

./brick_game/tetris/model/free_memory/free_tetris_field.c

#include "../s21_tetris_game_core.h"

void free_tetris_field(Tetris_Field* tetris_field) {
  if (tetris_field) {
    if (tetris_field->blocks) {
      free(tetris_field->blocks);
    }
    free(tetris_field);
  }
}

./brick_game/tetris/model/free_memory/free_tetris_figure.c

#include "../s21_tetris_game_core.h"

void free_tetris_figure(Tetris_Figure* tetris_figure) {
  if (tetris_figure) {
    if (tetris_figure->blocks) {
      free(tetris_figure->blocks);
    }
    free(tetris_figure);
  }
}

./brick_game/tetris/model/free_memory/free_tetris_figures_template.c

#include "../s21_tetris_game_core.h"

void free_tetris_figures_template(
    Tetris_Figures_Template* tetris_figures_template) {
  if (tetris_figures_template) {
    free(tetris_figures_template);
  }
}


./brick_game/tetris/model/move_figure.c

#include "s21_tetris_game_core.h"

void moveFigureDown(Tetris_Game* tetg) { tetg->figure->y++; }

void moveFigureUp(Tetris_Game* tetg) { tetg->figure->y--; }

void moveFigureRight(Tetris_Game* tetg) { tetg->figure->x++; }

void moveFigureLeft(Tetris_Game* tetg) { tetg->figure->x--; }

Tetris_Figure* rotTetFigure(Tetris_Game* tetg) {
  Tetris_Figure* t = create_memory_figure(tetg);
  Tetris_Figure* told = tetg->figure;
  t->x = told->x;
  t->y = told->y;
  t->color_pair = told->color_pair;
  for (int i = 0; i < t->size; i++) {
    for (int j = 0; j < t->size; j++) {
      t->blocks[i * t->size + j].b =
          told->blocks[(t->size - 1 - j) * t->size + i].b;
    }
  }
  return t;
}

./brick_game/tetris/model/print_high_score.c

#include "s21_tetris_game_core.h"

void print_high_score(Tetris_Game *tetris_game) {
  if (tetris_game->score > tetris_game->high_score) {
    tetris_game->high_score = tetris_game->score;
  }
}

./brick_game/tetris/model/processing_figures_after_falling.c

#include "s21_tetris_game_core.h"

int erasse_lines(Tetris_Game* tetg);
void drop_line(int i, Tetris_Field* tfl);

void plant_figure(Tetris_Game* tetris_game) {
  Tetris_Figure* tetris_figure = tetris_game->figure;
  for (int i = 0; i < tetris_figure->size; i++) {
    for (int j = 0; j < tetris_figure->size; j++) {
      if (tetris_figure->blocks[i * tetris_figure->size + j].b != 0) {
        int fx = tetris_figure->x + j;
        int fy = tetris_figure->y + i;
        tetris_game->field->blocks[fy * tetris_game->field->width + fx].b =
            tetris_figure->blocks[i * tetris_figure->size + j].b;
      }
    }
  }
}

int line_filled(int i, Tetris_Field* tfl) {
  for (int j = 0; j < tfl->width; j++) {
    if (tfl->blocks[i * tfl->width + j].b == 0) {
      return 0;
    }
  }
  return 1;
}

int erasse_lines(Tetris_Game* tetg) {
  Tetris_Field* tfl = tetg->field;
  int count = 0;
  for (int i = tfl->height - 1; i >= 0; i--) {
    while (line_filled(i, tfl)) {
      drop_line(i, tfl);
      count++;
    }
  }
  return count;
}

void drop_line(int i, Tetris_Field* tfl) {
  if (i == 0) {
    for (int j = 0; j < tfl->width; j++) {
      tfl->blocks[j].b = 0;
    }
  } else {
    for (int k = i; k > 0; k--) {
      for (int j = 0; j < tfl->width; j++) {
        tfl->blocks[k * tfl->width + j].b =
            tfl->blocks[(k - 1) * tfl->width + j].b;
      }
    }
  }
}


./brick_game/tetris/model/reset_game.c

#include "s21_tetris_game_core.h"

void reset_game(Tetris_Game* tetris_game) {
  for (int i = 0; i < tetris_game->field->width * tetris_game->field->height;
       i++) {
    tetris_game->field->blocks[i].b = 0;
  }
  tetris_game->playing = PLAYING;
  tetris_game->score = 0;
  tetris_game->level = 1;
  drop_new_figure(tetris_game);
}

./brick_game/tetris/model/s21_tetris_cli.h

// s21_tetris_cli.h
#ifndef TETRIS_CLI_H
#define TETRIS_CLI_H
#include <ncurses.h>

#include "s21_tetris_game_core.h"

#ifdef TEST_MODE
// При тестировании заглушка для curs_set
int curs_set(int visibility);
#else
#endif

/**
 * @brief Цветовая пара для игрового поля.
 */
#define color_field 8

/**
 * @brief Цветовая пара для следующей фигуры.
 */
#define color_field_next_figure 12

/**
 * @brief Цветовая пара для фигуры.
 */
#define color_figure 9

/**
 * @brief Цветовая пара для паузы.
 */
#define PAUSE_COLOR_PAIR 22

/**
 * @brief Отображает паузу в игре.
 *
 * @param win_game Указатель на окно игры.
 */
void cli_print_pause(WINDOW* win_game);

/**
 * @brief Отображает конец игры.
 *
 * @param tetris_game Указатель на игру.
 * @param win_game Указатель на окно игры.
 */
void cli_game_over(Tetris_Game* tetris_game, WINDOW* win_game);

/**
 * @brief Отображает игру в CLI.
 *
 * @param tetris_game Указатель на игру.
 * @param win_game Указатель на окно игры.
 * @param win_next_figure Указатель на окно следующей фигуры.
 * @param win_score_level Указатель на окно очков и уровня.
 * @param win_high_score Указатель на окно рекорда.
 */
void cli_print_game(Tetris_Game* tetris_game, WINDOW* win_game,
                    WINDOW* win_next_figure, WINDOW* win_score_level,
                    WINDOW* win_high_score);

/**
 * @brief Рисует фигуру в окне.
 *
 * @param figure Указатель на фигуру.
 * @param offset_x Смещение по X.
 * @param offset_y Смещение по Y.
 * @param win_next_figure Указатель на окно следующей фигуры.
 */
void cli_draw_figure(Tetris_Figure* figure, int offset_x, int offset_y,
                     WINDOW* win_next_figure);

/**
 * @brief Создает фреймы для игры.
 *
 * @param win_game Указатель на окно игры.
 * @param win_next_figure Указатель на окно следующей фигуры.
 * @param win_score_level Указатель на окно очков и уровня.
 * @param win_high_score Указатель на окно рекорда.
 * @return 0, если успешно, иначе код ошибки.
 */
int cli_create_frames_for_game(WINDOW** win_game, WINDOW** win_next_figure,
                               WINDOW** win_score_level,
                               WINDOW** win_high_score);

/**
 * @brief Отображает начальный экран.
 *
 * @param high_score Рекорд игры.
 * @param win_game Указатель на окно игры.
 * @param win_next_figure Указатель на окно следующей фигуры.
 * @param win_score_level Указатель на окно очков и уровня.
 * @param win_high_score Указатель на окно рекорда.
 */
void display_welcome_screen(int high_score, WINDOW* win_game,
                            WINDOW* win_next_figure, WINDOW* win_score_level,
                            WINDOW* win_high_score, int brick_game);

/**
 * @brief Обрабатывает паузу в игре.
 *
 * @param tetris_game Указатель на игру.
 * @param paused Указатель на переменную состояния паузы.
 * @param win_game Указатель на окно игры.
 */
void pause_processing(Tetris_Game* tetris_game, bool* paused, WINDOW* win_game);

/**
 * @brief Обрабатывает конец игры и сохраняет рекорд.
 *
 * @param tetris_game Указатель на игру.
 * @param win_game Указатель на окно игры.
 */
void game_over(Tetris_Game* tetris_game, WINDOW* win_game,
               int (*input_func)(void));

/**
 * @brief Выводит рекорд игры.
 *
 * @param tetris_game Указатель на игру.
 */
void print_high_score(Tetris_Game* tetris_game);

/**
 * @brief Ожидание нажатия Enter.
 */
void waiting_Enter();

/**
 * @brief Функция ввода (для обработки событий в CLI).
 */
int input_func(void);

/**
 * @brief Инициализация цветов.
 */
void initialization_of_colors();

#endif  // TETRIS_CLI_H

./brick_game/tetris/model/s21_tetris_game_core.h

// s21_tetris_game_core.h
#ifndef GAME_CORE_H
#define GAME_CORE_H

#include <errno.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

/**
 * @brief Начальное количество тиков.
 */
#define TET_TICK_START 30

/**
 * @brief Очки за очистку одной линии.
 */
#define score_for_1_line 100

/**
 * @brief Имя файла для сохранения рекорда.
 */
#define HIGH_SCORE_FILENAME "high_score.txt"

/**
 * @brief Перечисление состояний игры.
 */
enum { GAME_OVER = 0, PLAYING };

/**
 * @brief Перечисление действий игрока.
 */
enum {
  PLAYER_NOP = 0,
  PLAYER_UP,
  PLAYER_DOWN,
  PLAYER_LEFT,
  PLAYER_RIGHT,
  PLAYER_QUIT,
  PLAYER_PAUSE
};

/**
 * @brief Структура, представляющая кирпичик фигуры.
 */
typedef struct Tetris_Block {
  int b; /**< Значение кирпичика */
} Tetris_Block;

/**
 * @brief Структура, представляющая текущую фигуру (падающую).
 */
typedef struct Tetris_Figure {
  int x;                /**< Координата X фигуры */
  int y;                /**< Координата Y фигуры */
  int size;             /**< Размер фигуры */
  int color_pair;       /**< Цветовая пара фигуры */
  Tetris_Block* blocks; /**< Массив кирпичиков фигуры */
} Tetris_Figure;

/**
 * @brief Структура, представляющая шаблон фигур.
 */
typedef struct Tetris_Figures_Template {
  int number_of_figures; /**< Количество фигур */
  int size;              /**< Размер фигур */
  const Tetris_Block* blocks; /**< Массив кирпичиков шаблона фигур */
} Tetris_Figures_Template;

/**
 * @brief Структура, представляющая игровое поле.
 */
typedef struct Tetris_Field {
  int width;  /**< Ширина игрового поля */
  int height; /**< Высота игрового поля */
  Tetris_Block* blocks; /**< Массив кирпичиков игрового поля */
} Tetris_Field;

/**
 * @brief Структура, представляющая игрока.
 */
typedef struct Tetris_Player {
  int action; /**< Действие игрока */
} Tetris_Player;

/**
 * @brief Структура, представляющая игру.
 */
typedef struct Tetris_Game {
  Tetris_Field* field;        /**< Игровое поле */
  Tetris_Figure* figure;      /**< Текущая фигура */
  Tetris_Figure* next_figure; /**< Следующая фигура */
  Tetris_Figures_Template* figures_template; /**< Шаблон фигур */
  Tetris_Player* player;                     /**< Игрок */
  int ticks;       /**< Количество тиков */
  int ticks_left;  /**< Оставшееся количество тиков */
  int playing;     /**< Состояние игры */
  int score;       /**< Очки игрока */
  int level;       /**< Уровень игры */
  int high_score;  /**< Рекорд игры */
  int* figure_bag; /**< "Мешок" с фигурами */
  int bag_index;   /**< Индекс в "мешке" */
} Tetris_Game;

/**
 * @brief Внешний массив шаблонов фигур.
 */
extern const Tetris_Block figures_template[];

/**
 * @brief Создает шаблон фигур в памяти.
 *
 * @param number_of_figures Количество фигур.
 * @param figures_size Размер фигур.
 * @param figures_template Массив шаблонов фигур.
 * @return Указатель на созданный шаблон фигур.
 */
Tetris_Figures_Template* create_memory_figures_template(
    int number_of_figures, int figures_size,
    const Tetris_Block* figures_template);

/**
 * @brief Создает игровое поле в памяти.
 *
 * @param width Ширина игрового поля.
 * @param height Высота игрового поля.
 * @return Указатель на созданное игровое поле.
 */
Tetris_Field* create_memory_field(int width, int height);

/**
 * @brief Создает игру в памяти.
 *
 * @param field_width Ширина игрового поля.
 * @param field_height Высота игрового поля.
 * @param figures_size Размер фигур.
 * @param number_of_figures Количество фигур.
 * @param figures_template Массив шаблонов фигур.
 * @return Указатель на созданную игру.
 */
Tetris_Game* create_memory_game(int field_width, int field_height,
                                int figures_size, int number_of_figures,
                                const Tetris_Block* figures_template);

/**
 * @brief Перемещает фигуру вниз.
 *
 * @param tetg Указатель на игру.
 */
void moveFigureDown(Tetris_Game* tetg);

/**
 * @brief Перемещает фигуру вверх.
 *
 * @param tetg Указатель на игру.
 */
void moveFigureUp(Tetris_Game* tetg);

/**
 * @brief Перемещает фигуру вправо.
 *
 * @param tetg Указатель на игру.
 */
void moveFigureRight(Tetris_Game* tetg);

/**
 * @brief Перемещает фигуру влево.
 *
 * @param tetg Указатель на игру.
 */
void moveFigureLeft(Tetris_Game* tetg);

/**
 * @brief Проверяет столкновение фигуры.
 *
 * @param tetris_game Указатель на игру.
 * @return 1, если столкновение есть, иначе 0.
 */
int collision(Tetris_Game* tetris_game);

/**
 * @brief Размещает фигуру после падения.
 *
 * @param tetris_game Указатель на игру.
 */
void plant_figure(Tetris_Game* tetris_game);

/**
 * @brief Проверяет, заполнена ли линия.
 *
 * @param i Индекс линии.
 * @param tfl Указатель на игровое поле.
 * @return 1, если линия заполнена, иначе 0.
 */
int line_filled(int i, Tetris_Field* tfl);

/**
 * @brief Сдвигает линию вниз.
 *
 * @param i Индекс линии.
 * @param tfl Указатель на игровое поле.
 */
void drop_line(int i, Tetris_Field* tfl);

/**
 * @brief Очищает заполненные линии.
 *
 * @param tetg Указатель на игру.
 * @return Количество очищенных линий.
 */
int erasse_lines(Tetris_Game* tetg);

/**
 * @brief Создает фигуру в памяти.
 *
 * @param tetris_game Указатель на игру.
 * @return Указатель на созданную фигуру.
 */
Tetris_Figure* create_memory_figure(Tetris_Game* tetris_game);

/**
 * @brief Создает новую фигуру.
 *
 * @param tetris_game Указатель на игру.
 */
void drop_new_figure(Tetris_Game* tetris_game);

/**
 * @brief Поворачивает фигуру.
 *
 * @param tetg Указатель на игру.
 * @return Указатель на повернутую фигуру.
 */
Tetris_Figure* rotTetFigure(Tetris_Game* tetg);

/**
 * @brief Выполняет вычисления для игры.
 *
 * @param tetris_game Указатель на игру.
 * @return true, если состояние игры изменилось, иначе false.
 */
bool calculate(Tetris_Game* tetris_game);

/**
 * @brief Обрабатывает нажатие кнопок.
 *
 * @param ch Символ нажатой кнопки.
 * @param tetris_game Указатель на игру.
 */
void buttons_reaction(int ch, Tetris_Game* tetris_game);

/**
 * @brief Сбрасывает игру.
 *
 * @param tetg Указатель на игру.
 */
void reset_game(Tetris_Game* tetg);

/**
 * @brief Освобождает память, занятую "мешком" с фигурами.
 *
 * @param bag Указатель на "мешок" с фигурами.
 */
void free_figure_bag(int* bag);

/**
 * @brief Освобождает память, занятую шаблоном фигур.
 *
 * @param tetris_figures_template Указатель на шаблон фигур.
 */
void free_tetris_figures_template(
    Tetris_Figures_Template* tetris_figures_template);

/**
 * @brief Освобождает память, занятую игровым полем.
 *
 * @param tetris_field Указатель на игровое поле.
 */
void free_tetris_field(Tetris_Field* tetris_field);

/**
 * @brief Освобождает память, занятую игрой.
 *
 * @param tetris_game Указатель на игру.
 */
void free_memory_game(Tetris_Game* tetris_game);

/**
 * @brief Освобождает память, занятую фигурой.
 *
 * @param tetris_figure Указатель на фигуру.
 */
void free_tetris_figure(Tetris_Figure* tetris_figure);

/**
 * @brief Сохраняет рекорд игры.
 *
 * @param high_score Рекорд игры.
 */
void save_high_score(int high_score, int flag);

/**
 * @brief Загружает рекорд игры.
 *
 * @return Рекорд игры.
 */
int load_high_score(int flag);
void print_high_score(Tetris_Game* tetris_game);
void counting_score_and_level(Tetris_Game* tetris_game, int lines);
void execute_player_command(int action, Tetris_Game* tetris_game,
                            bool* state_changed);
Tetris_Figure* create_figure_from_template(Tetris_Game* tetris_game, int fnum);

/**
 * @brief Устанавливает скорость игры в зависимости от уровня.
 *
 * @param tetris_game Игровое состояние.
 * @param sp_start Начальное время.
 * @param sp_end Конечное время.
 * @param ts1 Временная переменная.
 * @param ts2 Временная переменная.
 */
void speed_from_level(struct Tetris_Game tetris_game,
                      const struct timespec sp_start,
                      const struct timespec sp_end, struct timespec* ts2);

#endif  // GAME_CORE_H


./brick_game/tetris/model/speed_from_level.c

#include <unistd.h>

#include "s21_tetris_game_core.h"

void speed_from_level(struct Tetris_Game tetris_game,
                      const struct timespec sp_start,
                      const struct timespec sp_end, struct timespec* ts2) {
  int base_delay = 33000000;  // Базовая задержка в наносекундах
  int level_delay_reduction = 3000000;  // Уменьшение задержки на каждом уровне
  int level_delay = base_delay - (tetris_game.level * level_delay_reduction);
  if (level_delay <= 3000000) {
    level_delay = 4500000;  // Минимальная задержка
  }
  if (sp_end.tv_sec - sp_start.tv_sec <= 0 &&
      (ts2->tv_nsec = level_delay - (sp_end.tv_nsec - sp_start.tv_nsec)) > 0) {
    nanosleep(ts2, NULL);
  }
}

./brick_game/tetris/model/templates.c

#include "s21_tetris_game_core.h"

//    0, 0, 0, 0,
//    1, 1, 1, 1,
//    0, 0, 0, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    1, 0, 0, 0,
//    1, 1, 1, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    0, 0, 1, 0,
//    1, 1, 1, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    0, 1, 1, 0,
//    0, 1, 1, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    0, 1, 1, 0,
//    1, 1, 0, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    0, 1, 0, 0,
//    1, 1, 1, 0,
//    0, 0, 0, 0,
//
//    0, 0, 0, 0,
//    1, 1, 0, 0,
//    0, 1, 1, 0,
//    0, 0, 0, 0,

const Tetris_Block figures_template[] = {
    {0}, {0}, {0}, {0}, {1}, {1}, {1}, {1}, {0}, {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0}, {0}, {1}, {0}, {0}, {0}, {1}, {1}, {1}, {0},
    {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {1}, {0}, {1}, {1},
    {1}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {1}, {1}, {0},
    {0}, {1}, {1}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {1},
    {1}, {0}, {1}, {1}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
    {0}, {1}, {0}, {0}, {1}, {1}, {1}, {0}, {0}, {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {1}, {1}, {0}, {0}, {0}, {1}, {1}, {0}, {0}, {0}, {0}, {0}};

./brick_game/tetris/qt_controller/qt_tetris_controller.cpp

#include "qt_tetris_controller.h"

namespace s21 {

QtTetrisController::QtTetrisController(TetrisModel& model, QtTetrisView& view)
    : QObject(nullptr), model_(model), view_(view) {
  connect(&timer_, &QTimer::timeout, this, &QtTetrisController::onTimeout);
  connect(&view_, &QtTetrisView::keyPressed, this,
          &QtTetrisController::handleKeyPress);
  connect(&view_, &QtTetrisView::startGame, this,
          &QtTetrisController::startGame);
  connect(&view_, &QtTetrisView::keyReleased, this,
          &QtTetrisController::handleKeyRelease);
  connect(&view_, &QtTetrisView::restartRequested, this,
          &QtTetrisController::handleRestartRequest);
}

TetrisDrawData QtTetrisController::get_data_from_model(TetrisModel& model_) {
  TetrisDrawData data;
  data.field = model_.GetField();
  data.currentFigure = model_.GetCurrentFigure();
  data.nextFigure = model_.GetNextFigure();
  data.figurePos = model_.GetFigurePosition();
  data.score = model_.GetScore();
  data.highScore = model_.GetHighScore();
  data.level = model_.GetLevel();
  data.gameOver = model_.IsGameOver();
  data.paused = paused_;
  return data;
}

// сердце игры
void QtTetrisController::onTimeout() {
  model_.Tick();
  refresh_timer();
  view_.draw(get_data_from_model(model_));

  if (model_.IsGameOver()) {
    timer_.stop();
    save_high_score(model_.GetHighScore(), 1);
    // Ждём нажатия клавиши — сигнал будет из keyPressEvent
  }
}

void QtTetrisController::handleKeyPress(QKeyEvent* event) {
  if (model_.IsGameOver()) {
    model_.ResetGame();
    timer_.start(10);
    return;
  }

  if (event->key() == Qt::Key_Escape) {
    paused_ = !paused_;
    if (paused_) {
      view_.draw(get_data_from_model(model_));
      timer_.stop();
    } else
      timer_.start(500);
    return;
  }

  if (paused_) return;

  switch (event->key()) {
    case Qt::Key_Left:
      model_.Update(TetrisModel::MOVE_LEFT);
      break;
    case Qt::Key_Right:
      model_.Update(TetrisModel::MOVE_RIGHT);
      break;
    case Qt::Key_Down:
      model_.Update(TetrisModel::MOVE_DOWN);
      break;
    case Qt::Key_Up:
    case Qt::Key_Space:
      model_.Update(TetrisModel::ROTATE);
      break;
    case Qt::Key_Q:
      model_.Update(TetrisModel::QUIT);
      break;
    default:
      break;
  }

  onTimeout();
}

void QtTetrisController::handleKeyRelease(QKeyEvent* event) { Q_UNUSED(event); }

void QtTetrisController::handleRestartRequest() {
  emit view_.gameOver();  // теперь можно закрыть окно и вернуться в меню
}

void QtTetrisController::refresh_timer() {
  if (timer_.isActive()) {
    timer_.stop();
  }
  timer_.start(model_.GetDelay());
}

void QtTetrisController::startGame() {
  model_.ResetGame();
  timer_.start(model_.GetDelay());
}
}  // namespace s21


./brick_game/tetris/qt_controller/qt_tetris_controller.h

#ifndef QT_TETRIS_CONTROLLER_H
#define QT_TETRIS_CONTROLLER_H

// #include <QKeyEvent>
#include <QObject>
#include <QTimer>

#include "../../../gui/desktop/tetris/qt_tetris_view.h"
#include "../qt_model/qt_tetris_model.h"

namespace s21 {

class QtTetrisController : public QObject {
  Q_OBJECT

 public:
  QtTetrisController(TetrisModel& model, QtTetrisView& view);
  void refresh_timer();
  TetrisDrawData get_data_from_model(TetrisModel& model);

 private slots:
  void onTimeout();
  void handleKeyPress(QKeyEvent* event);
  void handleKeyRelease(QKeyEvent* event);
  void startGame();
  void handleRestartRequest();

 private:
  TetrisModel& model_;
  QtTetrisView& view_;
  QTimer timer_;
  bool paused_ = false;
};

}  // namespace s21

#endif  // QT_TETRIS_CONTROLLER_H


./brick_game/tetris/qt_model/qt_tetris_model.cpp

#include "qt_tetris_model.h"

namespace s21 {

TetrisModel::TetrisModel() {
  srand(time(nullptr));
  game_ = create_memory_game(10, 20, 4, 7, figures_template);
  game_->player = new Tetris_Player();
  game_->player->action = PLAYER_NOP;
  game_->high_score = LoadHighScore();
  drop_new_figure(game_);
}

TetrisModel::~TetrisModel() {
  if (game_->player) {
    delete game_->player;
  }
  free_memory_game(game_);
}

void TetrisModel::StartGame() {
  reset_game(game_);
  drop_new_figure(game_);
}

void TetrisModel::ResetGame() {
  reset_game(game_);
  drop_new_figure(game_);
  SaveHighScore(game_->high_score);
}

bool TetrisModel::Update(Action action) {
  bool state_changed = false;

  switch (action) {
    case MOVE_LEFT:
      moveFigureLeft(game_);
      if (collision(game_)) moveFigureRight(game_);
      state_changed = true;
      break;

    case MOVE_RIGHT:
      moveFigureRight(game_);
      if (collision(game_)) moveFigureLeft(game_);
      state_changed = true;
      break;

    case MOVE_DOWN:
      moveFigureDown(game_);
      if (collision(game_)) moveFigureUp(game_);
      state_changed = true;
      break;

    case ROTATE: {
      Tetris_Figure* rotated = rotTetFigure(game_);
      Tetris_Figure* old = game_->figure;
      game_->figure = rotated;
      if (collision(game_)) {
        game_->figure = old;
        free_tetris_figure(rotated);
      } else {
        free_tetris_figure(old);
      }
      state_changed = true;
      break;
    }

    case PAUSE:
      // Это лучше управлять в контроллере
      state_changed = true;
      break;

    case QUIT:
      game_->playing = GAME_OVER;
      state_changed = true;
      break;

    default:
      break;
  }

  return state_changed;
}

bool TetrisModel::Tick() {
  bool state_changed = calculate(game_);
  if (state_changed) {
    print_high_score(game_);
  }
  return state_changed;
}

int TetrisModel::GetScore() const { return game_->score; }
int TetrisModel::GetHighScore() const { return game_->high_score; }
int TetrisModel::GetLevel() const { return game_->level; }

bool TetrisModel::IsGameOver() const { return game_->playing == GAME_OVER; }
bool TetrisModel::IsPaused() const { return false; }  // TODO: add pause logic

std::vector<std::vector<int>> TetrisModel::GetField() const {
  std::vector<std::vector<int>> field(game_->field->height,
                                      std::vector<int>(game_->field->width));
  for (int i = 0; i < game_->field->height; ++i)
    for (int j = 0; j < game_->field->width; ++j)
      field[i][j] = game_->field->blocks[i * game_->field->width + j].b;
  return field;
}

std::pair<int, int> TetrisModel::GetFigurePosition() const {
  return {game_->figure->y, game_->figure->x};
}

std::vector<std::vector<int>> TetrisModel::GetCurrentFigure() const {
  std::vector<std::vector<int>> figure(game_->figure->size,
                                       std::vector<int>(game_->figure->size));
  for (int i = 0; i < game_->figure->size; ++i)
    for (int j = 0; j < game_->figure->size; ++j)
      figure[i][j] = game_->figure->blocks[i * game_->figure->size + j].b;
  return figure;
}

std::vector<std::vector<int>> TetrisModel::GetNextFigure() const {
  std::vector<std::vector<int>> next(
      game_->next_figure->size, std::vector<int>(game_->next_figure->size));
  for (int i = 0; i < game_->next_figure->size; ++i)
    for (int j = 0; j < game_->next_figure->size; ++j)
      next[i][j] =
          game_->next_figure->blocks[i * game_->next_figure->size + j].b;
  return next;
}

int TetrisModel::LoadHighScore() {
  return load_high_score(1);  // 1 - flag for tetris
}

void TetrisModel::SaveHighScore(int score) { save_high_score(score, 1); }

int TetrisModel::GetDelay() const {
  int base_delay_ns = 33000000;       // 33 мс
  int reduction_per_level = 3000000;  // 3 мс
  long long level_delay =
      base_delay_ns - ((long long)game_->level) * reduction_per_level;

  if (level_delay < 4500000) {  // 4.5 мс
    level_delay = 4500000;
  }

  // Переводим наносекунды в миллисекунды
  return level_delay / 1000000;
}

}  // namespace s21


./brick_game/tetris/qt_model/qt_tetris_model.h

#ifndef TETRIS_MODEL_H
#define TETRIS_MODEL_H

#include <cstdlib>
#include <utility>
#include <vector>

extern "C" {
#include "../../../brick_game/tetris/model/s21_tetris_game_core.h"
}

namespace s21 {

class TetrisModel {
 public:
  enum Direction { LEFT, RIGHT, DOWN, UP };
  enum Action {
    NOP = 0,
    MOVE_LEFT,
    MOVE_RIGHT,
    MOVE_DOWN,
    ROTATE,
    PAUSE,
    QUIT
  };

  TetrisModel();
  ~TetrisModel();

  void StartGame();
  void ResetGame();
  bool Update(Action action);
  bool Tick();

  int GetScore() const;
  int GetHighScore() const;
  int GetLevel() const;
  bool IsGameOver() const;
  bool IsPaused() const;
  int GetDelay() const;

  std::vector<std::vector<int>> GetField() const;
  std::pair<int, int> GetFigurePosition() const;
  std::vector<std::vector<int>> GetCurrentFigure() const;
  std::vector<std::vector<int>> GetNextFigure() const;
  Tetris_Game* game_;

 private:
  int LoadHighScore();
  void SaveHighScore(int score);
};

}  // namespace s21

#endif  // TETRIS_MODEL_H


./gui/cli/common_gui/welcome_cli/cli_display_welcome_screen.c

#include "../../../../brick_game/tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
void display_welcome_screen(int high_score, WINDOW* win_game,
                            WINDOW* win_next_figure, WINDOW* win_score_level,
                            WINDOW* win_high_score, int brick_game) {
  (void)high_score;
  (void)win_game;
  (void)win_next_figure;
  (void)win_score_level;
  (void)win_high_score;
  (void)brick_game;
}
#else
void display_welcome_screen(int high_score, WINDOW* win_game,
                            WINDOW* win_next_figure, WINDOW* win_score_level,
                            WINDOW* win_high_score, int brick_game) {
  refresh();
  initialization_of_colors();
  int max_y, max_x;
  getmaxyx(win_game, max_y, max_x);

  const char* messages_tetris[] = {
      " ", "[][][][]", "[]",          "[]",         "[]", " ",
      " ", " ",        "Press Enter", " to start",  " ",  " ",
      " ", " ",        " ",           "High Score", " ",  "====="};
  const char* messages_snake[] = {
      " ",          "  [][]  ", "[]    []", "  []    ",    "    []  ",
      "[]    []",   "  [][]  ", " ",        "Press Enter", " to start",
      " ",          " ",        " ",        " ",           " ",
      "High Score", " ",        "====="};
  const char** messages;
  int number_of_elements_array = 0;
  switch (brick_game) {
    case 1:
      messages = messages_tetris;
      number_of_elements_array = sizeof(messages_tetris) / sizeof(messages[0]);
      break;
    case 2:
      messages = messages_snake;
      number_of_elements_array = sizeof(messages_snake) / sizeof(messages[0]);
      break;
    default:
      break;
  }
  int start_x_messages[number_of_elements_array];
  int start_y = (max_y - number_of_elements_array) / 2;
  int number = high_score;
  int length_number = 0;
  if (number == 0)
    length_number = 1;
  else
    length_number = (int)log10(number) + 1;
  for (int message_index = 0; message_index < number_of_elements_array;
       message_index++) {
    start_x_messages[message_index] =
        (max_x - (int)strlen(messages[message_index])) / 2;
    if (message_index == number_of_elements_array - 1) {
      start_x_messages[message_index] =
          (max_x - (int)strlen(messages[message_index]) * 2 - length_number) /
          2;
      wattron(win_game, COLOR_PAIR(11));
      mvwprintw(win_game, start_y + message_index,
                start_x_messages[message_index], "%s %d %s",
                messages[message_index], number, "=====");
      wattroff(win_game, COLOR_PAIR(11));
    } else {
      wattron(win_game, COLOR_PAIR(10));
      mvwprintw(win_game, start_y + message_index,
                start_x_messages[message_index], "%s", messages[message_index]);
      wattroff(win_game, COLOR_PAIR(10));
    }
  }

  box(win_next_figure, 0, 0);
  box(win_game, 0, 0);
  box(win_score_level, 0, 0);
  box(win_high_score, 0, 0);
  wnoutrefresh(win_next_figure);
  wnoutrefresh(win_game);
  wnoutrefresh(win_score_level);
  wnoutrefresh(win_high_score);
  curs_set(0);

  doupdate();
}
#endif

./gui/cli/snake/snake_view.cpp

#include "snake_view.h"

#include <string>

#include "../../../brick_game/snake/model/snake_model.h"
#ifdef TEST_MODE
namespace s21 {
SnakeView::SnakeView(WINDOW* game_win, WINDOW* win_next_figure,
                     WINDOW* win_score_level, WINDOW* win_high_score) {
  (void)game_win;
  (void)win_next_figure;
  (void)win_score_level;
  (void)win_high_score;
}
void SnakeView::Draw(const SnakeModel& model) { (void)model; }
void SnakeView::DisplayPause() {}
void SnakeView::DisplayGameOver(const SnakeModel& model) { (void)model; }
void SnakeView::DrawGameWindow(const SnakeModel& model) { (void)model; }
void SnakeView::DrawScoreWindow(const SnakeModel& model) { (void)model; }
void SnakeView::DrawHighScoreWindow(const SnakeModel& model) { (void)model; }
void SnakeView::DrawTitleWindow() {}
}  // namespace s21
#else
namespace s21 {
SnakeView::SnakeView(WINDOW* game_win, WINDOW* win_next_figure,
                     WINDOW* win_score_level, WINDOW* win_high_score)
    : win_game_(game_win),
      win_next_figure_(win_next_figure),
      win_score_level_(win_score_level),
      win_high_score_(win_high_score) {}

void SnakeView::Draw(const SnakeModel& model) {
  if (model.IsPause()) {
    DisplayPause();
    return;
  }
  DrawGameWindow(model);
  DrawScoreWindow(model);
  DrawHighScoreWindow(model);
  DrawTitleWindow();
  doupdate();
}

void SnakeView::DisplayPause() {
  werase(win_game_);
  box(win_game_, 0, 0);
  std::string msg = "PAUSED";
  mvwprintw(win_game_, HEIGHT / 2, (WIDTH * 2 - msg.size() + 1) / 2, "%s",
            msg.c_str());
  wnoutrefresh(win_game_);
  doupdate();
}

void SnakeView::DisplayGameOver(const SnakeModel& model) {
  werase(win_game_);
  box(win_game_, 0, 0);
  std::string msg = model.GetScore() >= 200 ? "You Win!" : "Game Over!";
  mvwprintw(win_game_, HEIGHT / 2, (WIDTH * 2 - msg.size() + 1) / 2, "%s",
            msg.c_str());
  wnoutrefresh(win_game_);
  doupdate();
}

void SnakeView::DrawGameWindow(const SnakeModel& model) {
  werase(win_game_);
  box(win_game_, 0, 0);
  for (int y = 0; y < HEIGHT; ++y) {
    for (int x = 0; x < WIDTH; ++x) {
      int sym = 31;
      std::pair<int, int> cell = std::make_pair(y, x);
      if (cell == model.GetFood()) {
        sym = 33;
      } else if (std::find(model.GetSnake().begin(), model.GetSnake().end(),
                           cell) != model.GetSnake().end()) {
        sym = 32;
      }
      wattron(win_game_, COLOR_PAIR(sym));
      mvwaddch(win_game_, y + 1, x * 2 + 1, ' ');
      mvwaddch(win_game_, y + 1, x * 2 + 2, ' ');
      wattroff(win_game_, COLOR_PAIR(sym));
    }
  }
  wnoutrefresh(win_game_);
}

void SnakeView::DrawScoreWindow(const SnakeModel& model) {
  werase(win_score_level_);
  box(win_score_level_, 0, 0);
  wattron(win_score_level_, COLOR_PAIR(34));
  mvwprintw(win_score_level_, 1, 1, "Score: %d", model.GetScore());
  mvwprintw(win_score_level_, 2, 1, "Level: %d", model.GetLevel());
  wattroff(win_score_level_, COLOR_PAIR(34));
  wnoutrefresh(win_score_level_);
}

void SnakeView::DrawHighScoreWindow(const SnakeModel& model) {
  werase(win_high_score_);
  box(win_high_score_, 0, 0);
  wattron(win_high_score_, COLOR_PAIR(35));
  mvwprintw(win_high_score_, 1, 1, "High Score: %d", model.GetHighScore());
  wattroff(win_high_score_, COLOR_PAIR(35));
  wnoutrefresh(win_high_score_);
}

void SnakeView::DrawTitleWindow() {
  werase(win_next_figure_);
  box(win_next_figure_, 0, 0);
  std::string title = "Snake Game";
  int title_length = title.length();
  int win_width = getmaxx(win_next_figure_);
  int centered_x = (win_width - title_length) / 2;
  mvwprintw(win_next_figure_, 2, centered_x, "%s", title.c_str());
  wnoutrefresh(win_next_figure_);
}

}  // namespace s21
#endif  // TEST_MODE


./gui/cli/snake/snake_view.h

#ifndef S21_SNAKE_VIEW_H
#define S21_SNAKE_VIEW_H
extern "C" {
#include "../../../brick_game/tetris/model/s21_tetris_cli.h"
}
#include <ncurses.h>

#include "../../../brick_game/snake/cli_controller/s21_cli_snake.h"

namespace s21 {

class SnakeViewTest;
class SnakeView {
  friend class SnakeViewTest;

 public:
  SnakeView(WINDOW* game_win, WINDOW* win_next_figure, WINDOW* win_score_level,
            WINDOW* win_high_score);
  void Draw(const SnakeModel& model);
  void DisplayGameOver(const SnakeModel& model);
  void DisplayPause();

#ifdef TEST_MODE
  void Test_DrawGameWindow(const SnakeModel& model) { DrawGameWindow(model); }
  void Test_DrawScoreWindow(const SnakeModel& model) { DrawScoreWindow(model); }
  void Test_DrawHighScoreWindow(const SnakeModel& model) {
    DrawHighScoreWindow(model);
  }
  void Test_DrawTitleWindow() { DrawTitleWindow(); }
#endif

 private:
  WINDOW* win_game_;
  WINDOW* win_next_figure_;
  WINDOW* win_score_level_;
  WINDOW* win_high_score_;

  void DrawGameWindow(const SnakeModel& model);
  void DrawScoreWindow(const SnakeModel& model);
  void DrawHighScoreWindow(const SnakeModel& model);
  void DrawTitleWindow();
};

}  // namespace s21

#endif  // S21_SNAKE_VIEW_H


./gui/cli/tetris/game_over/cli_game_over.c

#include "../../../../brick_game/tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
void cli_game_over(Tetris_Game* tetris_game, WINDOW* win_game) {
  (void)tetris_game;
  (void)win_game;
}
#else
void cli_game_over(Tetris_Game* tetris_game, WINDOW* win_game) {
  int max_y, max_x;
  getmaxyx(win_game, max_y, max_x);  // Получаем размеры окна
  const char* messages[] = {"Congratulations!!",
                            " ",
                            "You have ",
                            "a new record!!",
                            " ",
                            "Record",
                            "",
                            "Game over!",
                            "Score: ",
                            "Level: ",
                            "Again?",
                            "(Enter/Esc)"};
  int number_of_elements_array = sizeof(messages) / sizeof(messages[0]);
  int start_x_messages[number_of_elements_array];
  int start_y = (max_y - number_of_elements_array + 2) / 2;
  int number = 0;
  int length_number = 0;

  int old_high_score = load_high_score(1);
  wattron(win_game, COLOR_PAIR(PAUSE_COLOR_PAIR));

  for (int message_index = 0; message_index < number_of_elements_array;
       message_index++) {
    if (tetris_game->score > old_high_score && tetris_game->score > 0) {
      if (message_index == 7) message_index = message_index + 2;
    } else {
      if (message_index == 0) {
        message_index = message_index + number_of_elements_array - 5;
        start_y = start_y - 5;
      }
    }
    start_x_messages[message_index] =
        (max_x - (int)strlen(messages[message_index])) / 2;
    number = (message_index == 6)   ? tetris_game->high_score
             : (message_index == 8) ? tetris_game->score
             : (message_index == 9) ? tetris_game->level
                                    : number;
    if (number == 0)
      length_number = 1;
    else
      length_number = (int)log10(number) + 1;
    if (message_index == number_of_elements_array - 6 ||
        message_index == number_of_elements_array - 4 ||
        message_index == number_of_elements_array - 3) {
      start_x_messages[message_index] =
          (max_x - (int)strlen(messages[message_index]) - length_number) / 2;
      mvwprintw(win_game, start_y + message_index,
                start_x_messages[message_index], "%s %d",
                messages[message_index], number);
    } else
      mvwprintw(win_game, start_y + message_index,
                start_x_messages[message_index], "%s", messages[message_index]);
  }
  wattroff(win_game, COLOR_PAIR(PAUSE_COLOR_PAIR));
  wrefresh(win_game);
}
#endif

./gui/cli/tetris/game_process/cli_create_frame_for_game.c

#include "../../../../brick_game/tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
int cli_create_frames_for_game(WINDOW** win_game, WINDOW** win_next_figure,
                               WINDOW** win_score_level,
                               WINDOW** win_high_score) {
  (void)win_game;
  (void)win_next_figure;
  (void)win_score_level;
  (void)win_high_score;
  return 0;
}
#else
// Создаем окно для игрового поля
int cli_create_frames_for_game(WINDOW **win_game, WINDOW **win_next_figure,
                               WINDOW **win_score_level,
                               WINDOW **win_high_score) {
  int max_y, max_x;
  getmaxyx(stdscr, max_y, max_x);  // Получаем размеры экрана

  int width_game = 22;
  int height_game = 22;
  int height_top = 5;     // высота верхнего окна
  int height_bottom = 4;  // высота нижнего окна

  // Вычисляем координаты центрального окна
  int start_x_game = (max_x - width_game) / 2;
  int start_y_game = (max_y - height_game) / 2;

  // Вычисляем координаты верхнего окна
  int start_x_top = start_x_game;
  int start_y_top = start_y_game - height_top;

  // Вычисляем координаты нижнего окна
  int start_x_bottom = start_x_game;
  int start_y_bottom = start_y_game + height_game;

  // Вычисляем координаты самого нижнего окна
  int start_x_bottom_bottom = start_x_bottom;
  int start_y_bottom_bottom = start_y_bottom + 4;

  // Создаем окна
  *win_game = newwin(height_game, width_game, start_y_game, start_x_game);
  *win_next_figure = newwin(height_top, width_game, start_y_top, start_x_top);
  *win_score_level =
      newwin(height_bottom, width_game, start_y_bottom, start_x_bottom);
  *win_high_score =
      newwin(3, width_game, start_y_bottom_bottom, start_x_bottom_bottom);

  // Проверка на ошибки при создании окон
  if (*win_game == NULL || *win_next_figure == NULL ||
      *win_score_level == NULL || *win_high_score == NULL) {
    return 1;  // Возвращаем ошибку
  }

  return 0;
}
#endif

./gui/cli/tetris/game_process/cli_print_game.c

#include "../../../../brick_game/tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
void initialization_of_colors() { (void)0; }
#else

void cli_print_game(Tetris_Game* tetris_game, WINDOW* win_game,
                    WINDOW* win_next_figure, WINDOW* win_score_level,
                    WINDOW* win_high_score) {
  wclear(win_game);
  initialization_of_colors();
  Tetris_Field* tetris_field = tetris_game->field;
  Tetris_Figure* tetris_figure = tetris_game->figure;
  for (int i = 0; i < tetris_field->height; i++) {
    for (int j = 0; j < tetris_field->width; j++) {
      int sym = color_field;
      if (tetris_field->blocks[i * tetris_field->width + j].b != 0) {
        sym = color_figure;
      } else {
        int x = j - tetris_figure->x;
        int y = i - tetris_figure->y;
        if (x >= 0 && x < tetris_figure->size && y >= 0 &&
            y < tetris_figure->size) {
          if (tetris_figure->blocks[y * tetris_figure->size + x].b != 0) {
            sym = tetris_game->figure->color_pair;
          }
        }
      }
      wattron(win_game, COLOR_PAIR(sym));
      mvwaddch(win_game, i + 1, j * 2 + 1, ' ');
      mvwaddch(win_game, i + 1, j * 2 + 2, ' ');
      wattroff(win_game, COLOR_PAIR(sym));
    }
  }

  wclear(win_next_figure);
  Tetris_Figure* next_figure = tetris_game->next_figure;
  int offset_x = (getmaxx(win_next_figure) - next_figure->size * 2) / 2;
  int offset_y = 1;
  cli_draw_figure(next_figure, offset_x, offset_y, win_next_figure);

  wclear(win_score_level);
  wattron(win_score_level, COLOR_PAIR(10));
  mvwprintw(win_score_level, 1, 1, "Score: %d", tetris_game->score);
  mvwprintw(win_score_level, 2, 1, "Level: %d", tetris_game->level);
  wattroff(win_score_level, COLOR_PAIR(10));

  wclear(win_high_score);
  wattron(win_high_score, COLOR_PAIR(11));
  mvwprintw(win_high_score, 1, 1, "High score: %d", tetris_game->high_score);
  wattroff(win_high_score, COLOR_PAIR(11));

  box(win_game, 0, 0);
  box(win_next_figure, 0, 0);
  box(win_score_level, 0, 0);
  box(win_high_score, 0, 0);
  wnoutrefresh(win_game);
  wnoutrefresh(win_next_figure);
  wnoutrefresh(win_score_level);
  wnoutrefresh(win_high_score);
  curs_set(0);

  doupdate();
}

void cli_draw_figure(Tetris_Figure* figure, int offset_x, int offset_y,
                     WINDOW* win_next_figure) {
  for (int i = 0; i < figure->size; i++) {
    for (int j = 0; j < figure->size; j++) {
      int sym = color_field_next_figure;
      if (figure->blocks[i * figure->size + j].b != 0) {
        sym = figure->color_pair;
      }
      wattron(win_next_figure, COLOR_PAIR(sym));
      mvwaddch(win_next_figure, offset_y + i, offset_x + j * 2, ' ');
      mvwaddch(win_next_figure, offset_y + i, offset_x + j * 2 + 1, ' ');
      wattroff(win_next_figure, COLOR_PAIR(sym));
    }
  }
}

void initialization_of_colors() {
  start_color();
  init_pair(1, COLOR_RED, COLOR_RED);  // Цвет для фигуры с индексом 0
  init_pair(2, COLOR_CYAN, COLOR_CYAN);  // Цвет для фигуры с индексом 1
  init_pair(3, COLOR_YELLOW, COLOR_YELLOW);  // Цвет для фигуры с индексом 2
  init_pair(4, COLOR_WHITE, COLOR_MAGENTA);  // Цвет для фигуры с индексом 3
  init_pair(5, COLOR_GREEN, COLOR_GREEN);  // Цвет для фигуры с индексом 4
  init_pair(6, COLOR_BLUE, COLOR_BLUE);  // Цвет для фигуры с индексом 5
  init_pair(7, COLOR_MAGENTA, COLOR_MAGENTA);  // Цвет для фигуры с индексом 6

  init_pair(color_field, COLOR_BLACK, COLOR_WHITE);  // Поле основное
  init_pair(color_field_next_figure, COLOR_BLACK,
            COLOR_BLACK);  // Поле доп. фигуры

  init_pair(color_figure, COLOR_GREEN, COLOR_GREEN);  // Фигуры на поле
  init_pair(10, COLOR_YELLOW, COLOR_BLACK);           // Цвет шрифта
  init_pair(11, COLOR_CYAN, COLOR_BLACK);  // Цвет шрифта рекорда
  init_pair(13, COLOR_BLACK, COLOR_CYAN);  // Цвет шрифта рекорда

  init_pair(PAUSE_COLOR_PAIR, COLOR_RED, COLOR_WHITE);
  //     COLOR_BLACK
  //     COLOR_RED
  //     COLOR_GREEN
  //     COLOR_YELLOW
  //     COLOR_BLUE
  //     COLOR_MAGENTA
  //     COLOR_CYAN
  //     COLOR_WHITE

  init_pair(31, COLOR_WHITE, COLOR_WHITE);
  init_pair(32, COLOR_GREEN, COLOR_GREEN);
  init_pair(33, COLOR_RED, COLOR_RED);
  init_pair(34, COLOR_YELLOW, COLOR_BLACK);
  init_pair(35, COLOR_MAGENTA, COLOR_BLACK);
  init_pair(310, COLOR_CYAN, COLOR_BLACK);
  init_pair(311, COLOR_YELLOW, COLOR_BLACK);
}
#endif

./gui/cli/tetris/game_process/cli_print_pause.c

#include "../../../../brick_game/tetris/model/s21_tetris_cli.h"
#ifdef TEST_MODE
void cli_print_pause(WINDOW* win_game) { (void)win_game; }
#else

void cli_print_pause(WINDOW* win_game) {
  wattron(win_game, COLOR_PAIR(PAUSE_COLOR_PAIR));
  int max_y, max_x;
  getmaxyx(win_game, max_y, max_x);  // Получаем размеры окна

  const char* messages[] = {"Game paused.", "Press 'Esc'", "to resume.", " ",
                            "Press Q to quit."};
  int number_of_elements_array = sizeof(messages) / sizeof(messages[0]);
  int start_x_messages[number_of_elements_array];
  int start_y = (max_y - number_of_elements_array) / 2;
  for (int message_index = 0; message_index < number_of_elements_array;
       message_index++) {
    start_x_messages[message_index] =
        (max_x - (int)strlen(messages[message_index])) / 2;
    mvwprintw(win_game, start_y + message_index,
              start_x_messages[message_index], "%s", messages[message_index]);
  }

  wattroff(win_game, COLOR_PAIR(PAUSE_COLOR_PAIR));
  wrefresh(win_game);
}
#endif

./gui/desktop/launcher/launcher.pro

QT += core gui widgets

TARGET = GameLauncher
TEMPLATE = app

# --- Подключение заголовков ---
INCLUDEPATH += \
    ../tetris \
    ../snake \
    ../../../brick_game \
    ../../../brick_game/common/high_score \
    ../../../brick_game/tetris/model \
    ../../../brick_game/snake/model \
    ../../../brick_game/tetris/qt_controller \
    ../../../brick_game/snake/qt_controller \
    .

# --- Источники игр snake ---

SOURCES += \
    ../snake/main_window_snake.cpp \
        ../snake/qt_snake_view.cpp \

HEADERS += \
        ../snake/main_window_snake.h \
        ../snake/qt_snake_view.h

# Источники из библиотеки model common
SOURCES += \
        ../../../brick_game/snake/qt_controller/qt_snake_controller.cpp \
        ../../../brick_game/snake/model/snake_model.cpp

HEADERS += \
        ../../../brick_game/snake/qt_controller/qt_snake_controller.h \
        ../../../brick_game/snake/model/snake_model.h

RESOURCES += ../snake/resource.qrc


# --- Источники игр tetris ---

# Источники GUI
SOURCES += \
        ../tetris/main_window_tetris.cpp \
        ../tetris/qt_tetris_view.cpp


HEADERS += \
        ../tetris/main_window_tetris.h \
        ../tetris/qt_tetris_view.h

# Источники из модели и контроллера
SOURCES += \
        ../../../brick_game/tetris/qt_model/qt_tetris_model.cpp \
        ../../../brick_game/tetris/qt_controller/qt_tetris_controller.cpp \
        ../../../brick_game/tetris/model/calculate.c \
        ../../../brick_game/tetris/model/collision.c \
        ../../../brick_game/tetris/model/creating_memory_game_objects.c \
        ../../../brick_game/tetris/model/drop_new_figure.c \
        ../../../brick_game/tetris/model/templates.c \
        ../../../brick_game/tetris/model/free_memory/free_figure_bag.c \
        ../../../brick_game/tetris/model/free_memory/free_memory_game.c \
        ../../../brick_game/tetris/model/free_memory/free_tetris_field.c \
        ../../../brick_game/tetris/model/free_memory/free_tetris_figure.c\
        ../../../brick_game/tetris/model/free_memory/free_tetris_figures_template.c\
        ../../../brick_game/tetris/model/move_figure.c\
        ../../../brick_game/tetris/model/speed_from_level.c \
        ../../../brick_game/tetris/model/processing_figures_after_falling.c \
        ../../../brick_game/tetris/model/print_high_score.c\
        ../../../brick_game/tetris/model/reset_game.c

HEADERS += \
        ../../../brick_game/tetris/qt_model/qt_tetris_model.h \
        ../../../brick_game/tetris/qt_controller/qt_tetris_controller.h \
        ../../../brick_game/tetris/model/s21_tetris_game_core.h

# Ресурсы (изображения)
RESOURCES += ../tetris/resource_tetris.qrc


# --- Общие утилиты ---
SOURCES += \
    main.cpp \
    qt_choose_game_view.cpp \
    ../../../brick_game/common/high_score/load_high_score.c \
    ../../../brick_game/common/high_score/save_high_score.c

HEADERS += \
    ../../../brick_game/common/high_score/high_score.h \
    qt_choose_game_view.h


# --- SDK warning ---
CONFIG += sdk_no_version_check


./gui/desktop/launcher/main.cpp

#include <QApplication>

#include "qt_choose_game_view.h"

// Подключаем главные окна игр
#include "../snake/main_window_snake.h"
#include "../tetris/main_window_tetris.h"

int main(int argc, char* argv[]) {
  QApplication app(argc, argv);

  QtChooseGameView chooseView;
  chooseView.resize(400, 300);  // Размер меню выбора

  QObject::connect(
      &chooseView, &QtChooseGameView::gameSelected, [&](int gameIndex) {
        chooseView.hide();

        if (gameIndex == 0) {  // Тетрис
          s21::MainWindowTetris* window = new s21::MainWindowTetris();
          window->show();
          // Подключаем сигнал для возврата к меню
          QObject::connect(window, &s21::MainWindowTetris::restartSelection,
                           [window, &chooseView]() {
                             chooseView.show();
                             window->setAttribute(Qt::WA_DeleteOnClose);
                             window->close();
                           });

        } else if (gameIndex == 1) {  // Змейка
          s21::MainWindowSnake* window = new s21::MainWindowSnake();
          window->show();
          // Подключаем сигнал для возврата к меню
          QObject::connect(window, &s21::MainWindowSnake::restartSelection,
                           [window, &chooseView]() {
                             chooseView.show();
                             window->setAttribute(Qt::WA_DeleteOnClose);
                             window->close();
                           });
        }
      });

  chooseView.show();
  return app.exec();
}


./gui/desktop/launcher/qt_choose_game_view.cpp

#include "qt_choose_game_view.h"

QtChooseGameView::QtChooseGameView(QWidget* parent) : QWidget(parent) {
  setWindowTitle("Выбор игры");
  resize(400, 300);

  QVBoxLayout* layout = new QVBoxLayout(this);

  QLabel* label = new QLabel("Выберите игру:", this);
  label->setAlignment(Qt::AlignCenter);
  layout->addWidget(label);

  QPushButton* tetrisButton = new QPushButton("Тетрис", this);
  QPushButton* snakeButton = new QPushButton("Змейка", this);

  layout->addWidget(tetrisButton);
  layout->addWidget(snakeButton);

  connect(tetrisButton, &QPushButton::clicked, [this]() {
    emit gameSelected(0);  // Тетрис
  });

  connect(snakeButton, &QPushButton::clicked, [this]() {
    emit gameSelected(1);  // Змейка
  });
}


./gui/desktop/launcher/qt_choose_game_view.h

#ifndef QT_CHOOSE_GAME_VIEW_H
#define QT_CHOOSE_GAME_VIEW_H

#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QWidget>

class QtChooseGameView : public QWidget {
  Q_OBJECT

 public:
  explicit QtChooseGameView(QWidget *parent = nullptr);

 signals:
  void gameSelected(int gameIndex);  // 0 - Tetris, 1 - Snake
};

#endif  // QT_CHOOSE_GAME_VIEW_H


./gui/desktop/snake/main_window_snake.cpp

#include "main_window_snake.h"

namespace s21 {

MainWindowSnake::MainWindowSnake(QWidget* parent)
    : QMainWindow(parent), view_(this), controller_(model_, view_) {
  connect(&controller_, &QtSnakeController::requestReturnToMenu, this,
          &MainWindowSnake::restartSelection);

  setCentralWidget(&view_);
  resize(400, 900);
  setWindowTitle("Snake Game");
  show();
}

}  // namespace s21


./gui/desktop/snake/main_window_snake.h

#ifndef MAIN_WINDOW_SNAKE_H
#define MAIN_WINDOW_SNAKE_H

#include <QMainWindow>

#include "../../../brick_game/snake/model/snake_model.h"
#include "../../../brick_game/snake/qt_controller/qt_snake_controller.h"
#include "qt_snake_view.h"

namespace s21 {

class MainWindowSnake : public QMainWindow {
  Q_OBJECT

 public:
  explicit MainWindowSnake(QWidget* parent = nullptr);

 signals:
  void restartSelection();

 private:
  SnakeModel model_;
  QtSnakeView view_;
  QtSnakeController controller_;
};

}  // namespace s21

#endif  // MAIN_WINDOW_SNAKE_H


./gui/desktop/snake/qt_snake_view.cpp

#include "qt_snake_view.h"

namespace s21 {

QtSnakeView::QtSnakeView(QWidget* parent) : QWidget(parent) {
  setFocusPolicy(Qt::StrongFocus);
  setFocus();
}

void QtSnakeView::draw(const SnakeDrawData& data) {
  draw_data_ = data;
  update();
}

void QtSnakeView::paintEvent(QPaintEvent* event) {
  Q_UNUSED(event);
  QPainter painter(this);
  painter.fillRect(rect(), QColor("#FFFACD"));

  if (draw_data_.start_screen) {
    draw_welcome_screen(painter);
    return;
  }

  // Рисуем игровое поле
  painter.fillRect(0, 0, 400, 800, QColor("#E6F7FF"));  // нежно-голубой
  drawSnake(painter);
  drawApple(painter);
  drawScoreLevelPause(painter);

  if (draw_data_.game_over) {
    drawGameOverWin(painter);
  }

}  // paintEvent

void QtSnakeView::draw_welcome_screen(QPainter& painter) {
  painter.fillRect(rect(), QColor("skyblue"));
  // Солнце
  painter.setBrush(Qt::yellow);
  painter.drawEllipse(350, 20, 30, 30);
  for (int i = 0; i < 12; ++i) {
    painter.save();
    painter.translate(365, 35);
    painter.rotate(i * 30);
    painter.drawLine(0, -20, 0, -35);
    painter.restore();
  }

  // Текст "ЗМЕЙКА"
  painter.setPen(QColor("#FF1493"));
  painter.setFont(QFont("Comic Sans MS", 48, QFont::Bold));
  QRect titleRect(0, 200, width(), 100);
  painter.drawText(titleRect, Qt::AlignCenter, "ЗМЕЙКА");

  // Подпись
  painter.setPen(QColor("#228B22"));
  painter.setFont(QFont("Comic Sans MS", 18));
  QRect subtitleRect(0, 800, width(), 50);
  painter.drawText(subtitleRect, Qt::AlignCenter, "Нажмите Enter для старта");

  // Змейка (картинка)
  QImage snake(":/resourses_files/images/snake.png");
  if (!snake.isNull()) {
    int imgWidth = 250;
    int imgHeight = 250;
    QImage scaledSnake = snake.scaled(imgWidth, imgHeight, Qt::KeepAspectRatio,
                                      Qt::SmoothTransformation);
    int imageX = (rect().width() - imgWidth) / 2;
    painter.drawImage(imageX, 380, scaledSnake);
  } else {
    qDebug() << "[ERROR] Welcome image not found!";
    // Буква S (жирная)
    QPen sPen;
    sPen.setColor(QColor("#32CD32"));  // Лаймово-зелёный
    sPen.setWidth(15);  // Толщина линии — делаем жирнее!
    sPen.setCapStyle(Qt::RoundCap);  // Скругление концов — красивее
    sPen.setJoinStyle(Qt::RoundJoin);  // Скругление углов соединений
    painter.setPen(sPen);
    painter.setBrush(Qt::NoBrush);

    QRect s_rect(140, 400, 120, 60);  // x, y, ширина, высота
    painter.drawArc(s_rect, 90 * 16, 180 * 16);  // верхняя половина
    painter.drawArc(s_rect.adjusted(0, 60, 0, 60), 90 * 16,
                    -180 * 16);  // нижняя половина
  }
}

void QtSnakeView::drawSnake(QPainter& painter) {
  int segmentIndex = 0;
  int totalSegments = draw_data_.snake.size();

  for (const auto& dot : draw_data_.snake) {
    // Вычисляем интенсивность зелёного цвета в зависимости от позиции
    // от 50 до 250
    int greenValue = 50 + (200 * segmentIndex) / totalSegments;
    // RGB: только зелёный канал меняется
    painter.setBrush(QColor(0, greenValue, 0));
    // Рисуем блок
    painter.drawRect(dot.second * 40, dot.first * 40, 40, 40);
    segmentIndex++;
  }
}

void QtSnakeView::drawApple(QPainter& painter) {
  const auto& food = draw_data_.food;
  QImage apple(":/resourses_files/images/apple.jpg");

  if (!apple.isNull()) {
    // Масштабируем изображение под размер блока (40x40)
    QImage scaledApple =
        apple.scaled(40, 40, Qt::KeepAspectRatio, Qt::SmoothTransformation);

    // Рисуем яблоко на координатах еды
    painter.drawImage(food.second * 40, food.first * 40, scaledApple);
  } else {
    qDebug() << "Ошибка: Изображение не загружено из .qrc!";
    painter.setBrush(QColor("#FFD700"));  // Золотистый цвет
    painter.drawEllipse(food.second * 40 + 5, food.first * 40 + 5, 30, 30);

    // Глазки
    painter.setBrush(Qt::white);
    painter.drawEllipse(food.second * 40 + 12, food.first * 40 + 12, 5, 5);
    painter.drawEllipse(food.second * 40 + 23, food.first * 40 + 12, 5, 5);
  }
}

void QtSnakeView::drawScoreLevelPause(QPainter& painter) {
  // Рисуем уровень
  painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));
  painter.setPen(QColor("#4B0082"));  // Темно-фиолетовый
  painter.drawText(30, 840, QString("Уровень: %1").arg(draw_data_.level));

  // Рисуем счёт
  painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));
  painter.setPen(QColor("#FF69B4"));  // розовый
  painter.drawText(30, 880, QString("Очки: %1").arg(draw_data_.score));

  // Рисуем рекорд
  painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));
  painter.setPen(QColor("#00CED1"));  //  тёмно-циан
  painter.drawText(230, 840, QString("Рекорд: %1").arg(draw_data_.high_score));

  // Рисуем паузу
  if (draw_data_.paused) {
    painter.fillRect(rect(), QColor(0, 0, 0, 180));  // затемнение
    painter.setPen(Qt::red);
    painter.setFont(QFont("Comic Sans MS", 34, QFont::Bold));
    painter.drawText(rect(), Qt::AlignCenter, "ПАУЗА");
    //    qDebug() << "зашли в метод отрисовки паузы";
  }
}

void QtSnakeView::drawGameOverWin(QPainter& painter) {
  painter.fillRect(rect(), QColor(0, 0, 0, 180));  // затемнение
  painter.setPen(Qt::red);
  painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));

  if (draw_data_.win) {
    painter.drawText(rect(), Qt::AlignCenter,
                     "🎉 ПОБЕДА 🎉\n\nПоздравляем!\nВы собрали 200 очков!");
  } else {
    painter.drawText(rect(), Qt::AlignCenter, "ИГРА ОКОНЧЕНА");
    // Подпись
    painter.setPen(QColor("#FF1493"));
    painter.setFont(QFont("Comic Sans MS", 18));
    QRect subtitleRect(0, 700, width(), 50);
    painter.drawText(subtitleRect, Qt::AlignCenter,
                     "Enter - Попробовать ещё раз.\nEscape - Выход.");
  }

  painter.setPen(Qt::white);
  painter.setFont(QFont("Arial", 16));
  QString scoreText = QString("Score: %1").arg(draw_data_.score);
  painter.drawText(rect(), Qt::AlignBottom | Qt::AlignHCenter, scoreText);

  painter.setFont(QFont("Arial", 12));
  QString highScoreText = QString("High Score: %1").arg(draw_data_.high_score);
  painter.drawText(rect(), Qt::AlignBottom | Qt::AlignLeft, highScoreText);

  QString restartText = "Press any key to restart";
  painter.drawText(rect(), Qt::AlignBottom | Qt::AlignRight, restartText);
}

void QtSnakeView::keyPressEvent(QKeyEvent* event) { emit keyPressed(event); }

void QtSnakeView::keyReleaseEvent(QKeyEvent* event) { emit keyReleased(event); }
}  // namespace s21


./gui/desktop/snake/qt_snake_view.h

#ifndef QT_SNAKE_VIEW_H
#define QT_SNAKE_VIEW_H

#include <QKeyEvent>
#include <QPainter>
#include <QWidget>
#include <deque>
#include <utility>

#include "../../../brick_game/snake/model/snake_model.h"
namespace s21 {

struct SnakeDrawData {
  std::deque<std::pair<int, int>> snake;
  std::pair<int, int> food;
  int score = 0;
  bool paused = false;
  bool game_over = false;
  bool win = false;
  bool start_screen = true;
  int high_score = 0;
  int level = 1;
};

class QtSnakeView : public QWidget {
  Q_OBJECT
 public:
  explicit QtSnakeView(QWidget* parent = nullptr);
  void draw(const SnakeDrawData& data);  // Принимаем структуру для отрисовки

 signals:
  void keyPressed(QKeyEvent* event);
  void keyReleased(QKeyEvent* event);

 protected:
  void paintEvent(QPaintEvent* event) override;
  void keyPressEvent(QKeyEvent* event) override;
  void keyReleaseEvent(QKeyEvent* event) override;

 private:
  SnakeDrawData draw_data_;  // Храним данные для отрисовки
  void draw_welcome_screen(QPainter& painter);
  void drawSnake(QPainter& painter);
  void drawApple(QPainter& painter);
  void drawScoreLevelPause(QPainter& painter);
  void drawGameOverWin(QPainter& painter);
};

}  // namespace s21

#endif  // QT_SNAKE_VIEW_H


./gui/desktop/snake/snake_gui.pro

# snake_gui.pro

QT += core gui widgets

TARGET = SnakeGame
TEMPLATE = app

# Указываем стандарт C++20
QMAKE_CXXFLAGS += -std=c++20

# Отключаем устаревшие предупреждения Qt
DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000

# Источники
SOURCES += \
        qt_snake_view.cpp \
        main_window.cpp \
        main.cpp \


HEADERS += \
        qt_snake_view.h \
        main_window.h


# Источники из библиотеки model common
SOURCES += \
        ../../../brick_game/snake/qt_controller/qt_snake_controller.cpp \
        ../../../brick_game/snake/model/snake_model.cpp \
        ../../../brick_game/common/high_score/load_high_score.c \
        ../../../brick_game/common/high_score/save_high_score.c
HEADERS += \
        ../../../brick_game/snake/qt_controller/qt_snake_controller.h \
        ../../../brick_game/snake/model/snake_model.h \
        ../../../brick_game/common/high_score/high_score.h

RESOURCES += resource.qrc


./gui/desktop/tetris/main_window_tetris.cpp

#include "main_window_tetris.h"

namespace s21 {

MainWindowTetris::MainWindowTetris(QWidget* parent)
    : QMainWindow(parent), view_(this), controller_(model_, view_) {
  connect(&view_, &QtTetrisView::gameOver, this,
          [this]() { emit restartSelection(); });
  setCentralWidget(&view_);
  resize(400, 900);
  setWindowTitle("Tetris Game");

  show();
}

}  // namespace s21


./gui/desktop/tetris/main_window_tetris.h

#ifndef MAIN_WINDOW_H
#define MAIN_WINDOW_H

#include <QMainWindow>

#include "../../../brick_game/tetris/qt_controller/qt_tetris_controller.h"
#include "qt_tetris_view.h"

namespace s21 {

class MainWindowTetris : public QMainWindow {
  Q_OBJECT

 public:
  explicit MainWindowTetris(QWidget* parent = nullptr);

 signals:
  void restartSelection();

 private:
  TetrisModel model_;
  QtTetrisView view_;
  QtTetrisController controller_;
};

}  // namespace s21

#endif  // MAIN_WINDOW_H


./gui/desktop/tetris/qt_tetris_view.cpp

#include "qt_tetris_view.h"

namespace s21 {

QtTetrisView::QtTetrisView(QWidget* parent)
    : QWidget(parent), blockImage_(":/tetris_images/images/green_block.png") {
  if (!blockImage_.isNull()) {
    blockImage_ = blockImage_.scaled(30, 30, Qt::KeepAspectRatio,
                                     Qt::SmoothTransformation);
  }
  figureImages_.resize(4);
  QString imagePaths[4] = {":/tetris_images/images/blue_block.png",
                           ":/tetris_images/images/orange_block.png",
                           ":/tetris_images/images/red_block.png",
                           ":/tetris_images/images/green_block.png"};
  for (int i = 0; i < 4; ++i) {
    QImage img(imagePaths[i]);
    if (!img.isNull()) {
      img = img.scaled(30, 30, Qt::KeepAspectRatio, Qt::SmoothTransformation);
    }
    figureImages_[i] = img;
  }
  setFocusPolicy(Qt::StrongFocus);
}  // конец конструктора

void QtTetrisView::draw(const TetrisDrawData& data) {
  draw_data_ = data;
  gameStarted_ = true;
  update();  // вызывает paintEvent
}
////////////////////////////////////////////////////////////////////////
void QtTetrisView::paintEvent(QPaintEvent*) {
  QPainter painter(this);

  const int cellSize = 30;
  const int offsetX = 49;
  const int offsetY = 20;

  // Цвета
  QColor bgColor("#87CEFA");  // Небесно-голубой фон всего экрана

  // 1. Заливаем весь экран небесно-голубым
  painter.fillRect(rect(), bgColor);

  if (!gameStarted_) {
    DrawWelcomeScreen(painter);
    return;
  }

  // 2. Рисуем градиент только в области игрового поля
  QRect gameArea(offsetX - 5, offsetY - 5, (cellSize * 10) + 10,
                 (cellSize * 20) + 10);
  QLinearGradient gradient(gameArea.topLeft(), gameArea.bottomRight());
  gradient.setColorAt(0, QColor("#FFD700"));  // золотой
  gradient.setColorAt(1, QColor("#87CEEB"));  // голубой

  painter.fillRect(gameArea, QBrush(gradient));

  // Рамка вокруг основного поля
  QRect frameRect(offsetX - 5, offsetY - 5, (cellSize * 10) + 10,
                  (cellSize * 20) + 10);
  QPen borderPen(QColor("#00CED1"), 3);  // тёмно-циан
  painter.setPen(borderPen);
  painter.drawRect(frameRect);

  // 3. Рисуем игровое поле — все блоки зелёные
  for (size_t i = 0; i < draw_data_.field.size(); ++i) {
    for (size_t j = 0; j < draw_data_.field[i].size(); ++j) {
      if (draw_data_.field[i][j]) {
        painter.drawImage(offsetX + j * cellSize, offsetY + i * cellSize,
                          figureImages_[3]);  // green_block.png
      }
    }
  }

  // 4. Рисуем текущую (падающую) фигуру синим цветом
  auto [y, x] = draw_data_.figurePos;
  for (size_t i = 0; i < draw_data_.currentFigure.size(); ++i) {
    for (size_t j = 0; j < draw_data_.currentFigure[i].size(); ++j) {
      if (draw_data_.currentFigure[i][j]) {
        painter.drawImage(offsetX + (x + j) * cellSize,
                          offsetY + (y + i) * cellSize,
                          figureImages_[0]);  // blue_block.png
      }
    }
  }

  // 5. Рисуем следующую фигуру оранжевым цветом
  int nextOffsetX = 140;
  int nextOffsetY = 640;
  for (size_t i = 0; i < draw_data_.nextFigure.size(); ++i) {
    for (size_t j = 0; j < draw_data_.nextFigure[i].size(); ++j) {
      if (draw_data_.nextFigure[i][j]) {
        painter.drawImage(nextOffsetX + j * cellSize,
                          nextOffsetY + i * cellSize,
                          figureImages_[1]);  // orange_block.png
      }
    }
  }
  ///////////////////////////////////////////////////

  // Установка общих параметров
  painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));

  // Рисуем уровень
  painter.setPen(QColor("#4B0082"));  // Темно-фиолетовый
  painter.drawText(30, 840, QString("Уровень: %1").arg(draw_data_.level));

  // Рисуем счёт
  painter.setPen(QColor("#FF69B4"));  // розовый
  painter.drawText(30, 880, QString("Очки: %1").arg(draw_data_.score));

  // Рисуем рекорд
  painter.setPen(QColor("#FFD700"));  // золотой
  painter.drawText(230, 840, QString("Рекорд: %1").arg(draw_data_.highScore));

  // Рисуем паузу
  if (draw_data_.paused) {
    painter.fillRect(rect(), QColor(0, 0, 0, 180));  // затемнение
    painter.setPen(Qt::red);
    painter.setFont(QFont("Comic Sans MS", 34, QFont::Bold));
    painter.drawText(rect(), Qt::AlignCenter, "ПАУЗА");
    //    qDebug() << "зашли в метод отрисовки паузы";
  }

  if (draw_data_.gameOver) {
    painter.fillRect(rect(), QColor(0, 0, 0, 180));  // затемнение
    painter.setPen(QColor("#FFD700"));
    painter.setFont(QFont("Comic Sans MS", 24, QFont::Bold));

    if (draw_data_.highScore == draw_data_.score && draw_data_.highScore != 0) {
      painter.drawText(rect(), Qt::AlignCenter,
                       QString("🎉 ПОБЕДА 🎉\n\nПоздравляем!\n У вас новый "
                               "РЕКОРД!\n\n\n Рекорд: %1")
                           .arg(draw_data_.highScore));

    } else {
      painter.setPen(Qt::red);
      painter.drawText(rect(), Qt::AlignCenter,
                       QString("ИГРА ОКОНЧЕНА").arg(draw_data_.highScore));
      // Подпись
      painter.setPen(QColor("#FF1493"));
      painter.setFont(QFont("Comic Sans MS", 18));
      QRect subtitleRect(0, 550, width(), 50);
      painter.drawText(subtitleRect, Qt::AlignCenter,
                       "Enter - Попробовать ещё раз.\nEscape - Выход.");
    }
  }
}

void QtTetrisView::DrawWelcomeScreen(QPainter& painter) {
  // Фон
  QLinearGradient gradient(rect().topLeft(), rect().bottomRight());
  gradient.setColorAt(0, QColor("#87CEFA"));  // Небесно-голубой
  gradient.setColorAt(1, QColor("#E0FFFF"));  // Светло-голубой
  painter.fillRect(rect(), QBrush(gradient));

  // Рисуем букву "Т" из кубиков
  const int cellSize = 30;
  int startX = rect().width() / 2 - 2 * cellSize - 4;
  int startY = 100;

  for (int j = 0; j < 5; ++j) {
    painter.drawImage(startX + j * cellSize, startY,
                      figureImages_[(j % 4)]);  // разные цвета
  }
  for (int i = 1; i < 6; ++i) {
    painter.drawImage(startX + 2 * cellSize, startY + i * cellSize,
                      figureImages_[1]);  // оранжевый столбик
  }

  // Заголовок
  painter.setFont(QFont("Comic Sans MS", 28, QFont::Bold));
  painter.setPen(QColor("#4B0082"));  // темно-фиолетовый
  QString title = "Добро пожаловать\nв Тетрис!";
  int textX = (rect().width() - 300) / 2;  // примерная ширина текста
  int textY = startY + 8 * cellSize - 30;

  painter.drawText(QRect(textX, textY, 300, 100), Qt::AlignCenter, title);

  // картинка тетриса
  QImage welcomeImage(":/tetris_images/images/tetris_image.jpeg");
  if (!welcomeImage.isNull()) {
    // Масштабируем изображение под нужный размер
    int imgWidth = 250;
    int imgHeight = 250;
    welcomeImage = welcomeImage.scaled(imgWidth, imgHeight, Qt::KeepAspectRatio,
                                       Qt::SmoothTransformation);

    int imageX = (rect().width() - imgWidth) / 2;
    painter.drawImage(imageX, 450, welcomeImage);
  } else {
    qDebug() << "[ERROR] Welcome image not found!";
  }

  // Инструкция
  painter.setFont(QFont("Comic Sans MS", 20));
  painter.setPen(Qt::darkBlue);
  QString instruction = "Нажмите Enter, чтобы начать";
  int instrWidth = QFontMetrics(painter.font()).horizontalAdvance(instruction);
  painter.drawText((rect().width() - instrWidth) / 2, startY + 25 * cellSize,
                   instruction);
}

void QtTetrisView::keyPressEvent(QKeyEvent* event) {
  const auto key = event->key();
  const bool isEnterOrReturn = key == Qt::Key_Enter || key == Qt::Key_Return;

  if ((draw_data_.gameOver || !gameStarted_)) {
    if (isEnterOrReturn) {
      emit startGame();
      gameStarted_ = true;
      update();
      return;
    } else if (key == Qt::Key_Escape) {
      emit restartRequested();
      return;
    }
  } else
    emit keyPressed(event);
}

void QtTetrisView::keyReleaseEvent(QKeyEvent* event) {
  emit keyReleased(event);
}

}  // namespace s21


./gui/desktop/tetris/qt_tetris_view.h

#ifndef QT_TETRIS_VIEW_H
#define QT_TETRIS_VIEW_H

#include <QDebug>
#include <QKeyEvent>
#include <QPainter>
#include <QWidget>
#include <utility>
#include <vector>

namespace s21 {

struct TetrisDrawData {
  std::vector<std::vector<int>> field;
  std::vector<std::vector<int>> currentFigure;
  std::vector<std::vector<int>> nextFigure;
  std::pair<int, int> figurePos;
  int score = 0;
  int highScore = 0;
  int level = 1;
  bool gameOver = false;
  bool paused = false;
};

class QtTetrisView : public QWidget {
  Q_OBJECT

 public:
  explicit QtTetrisView(QWidget* parent = nullptr);
  void draw(const TetrisDrawData& data);
  void DrawWelcomeScreen(QPainter& painter);

 signals:
  void keyPressed(QKeyEvent*);
  void keyReleased(QKeyEvent*);
  void startGame();
  void restartRequested();
  void gameOver();

 protected:
  void paintEvent(QPaintEvent*) override;
  void keyPressEvent(QKeyEvent*) override;
  void keyReleaseEvent(QKeyEvent*) override;

 private:
  TetrisDrawData draw_data_;
  QImage blockImage_;
  std::vector<QImage> figureImages_;
  bool gameStarted_ = false;
};

}  // namespace s21

#endif  // QT_TETRIS_VIEW_H


./gui/desktop/tetris/tetris_gui.pro

# tetris_gui.pro

QT += core gui widgets

TARGET = TetrisGame
TEMPLATE = app

QMAKE_CXXFLAGS += -std=c++20

# Отключаем устаревшие предупреждения Qt
DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000
CONFIG += sdk_no_version_check

# Источники GUI
SOURCES += \
        qt_tetris_view.cpp \
        main_window.cpp \
        main.cpp


HEADERS += \
        qt_tetris_view.h \
        main_window.h

# Источники из модели и контроллера
SOURCES += \
        ../../../brick_game/common/high_score/load_high_score.c \
        ../../../brick_game/common/high_score/save_high_score.c \
        ../../../brick_game/tetris/qt_model/qt_tetris_model.cpp \
        ../../../brick_game/tetris/qt_controller/qt_tetris_controller.cpp \
        ../../../brick_game/tetris/model/calculate.c \
        ../../../brick_game/tetris/model/collision.c \
        ../../../brick_game/tetris/model/creating_memory_game_objects.c \
        ../../../brick_game/tetris/model/drop_new_figure.c \
        ../../../brick_game/tetris/model/templates.c \
        ../../../brick_game/tetris/model/free_memory/free_figure_bag.c \
        ../../../brick_game/tetris/model/free_memory/free_memory_game.c \
        ../../../brick_game/tetris/model/free_memory/free_tetris_field.c \
        ../../../brick_game/tetris/model/free_memory/free_tetris_figure.c\
        ../../../brick_game/tetris/model/free_memory/free_tetris_figures_template.c\
        ../../../brick_game/tetris/model/move_figure.c\
        ../../../brick_game/tetris/model/speed_from_level.c \
        ../../../brick_game/tetris/model/processing_figures_after_falling.c \
        ../../../brick_game/tetris/model/print_high_score.c\
        ../../../brick_game/tetris/model/reset_game.c

HEADERS += \
        ../../../brick_game/tetris/qt_model/qt_tetris_model.h \
        ../../../brick_game/tetris/qt_controller/qt_tetris_controller.h \
        ../../../brick_game/tetris/model/s21_tetris_game_core.h \
        ../../../brick_game/common/high_score/high_score.h

# Ресурсы (например, изображения)
RESOURCES += resource_tetris.qrc


./Makefile

.PHONY: all install uninstall dvi dist test gcov_report check rebuild clean

# Целевой исполняемый файл
TARGET = s21_brick_games_terminal_sueannel

# Компиляторы
CC = gcc -g -Wall -Wextra -Werror 
CXX = g++  -g -Wall -Wextra -Werror -std=c++20

# Флаги компиляции
GCOVFLAGS = -fprofile-arcs -ftest-coverage -lncurses
TEST_FLAGS = -D TEST_MODE

# Операционная система
OS=$(shell uname -s)
Gtest=-lgtest -lgtest_main -pthread
LIBS=$(Gtest)
LINUX=$(Gtest) -lm -lpthread -lrt -lsubunit
ifeq ($(OS), Linux)
 CC += -D OS_LINUX
 CXX += -D OS_LINUX
endif
ifeq ($(OS), Darwin)
 CC += -D OS_MAC
 CXX += -D OS_MAC
endif

# Поддиректории и заголовочные файлы
SUBDIRS = brick_game/snake/cli_controller \
			brick_game/snake/model \
			gui/cli \
			brick_game/common \
			brick_game/tetris/model \
			brick_game/tetris/controller


# Список исходных файлов
SOURCES = $(shell find $(SUBDIRS) -type f \( -name '*.c' -o -name '*.cpp' \))

# Разделение на C и C++ файлы
C_SOURCES := $(filter %.c,$(SOURCES))
CPP_SOURCES := $(filter %.cpp,$(SOURCES))

# Объектные файлы
C_OBJS := $(patsubst %.c, %.o, $(C_SOURCES))
CPP_OBJS := $(patsubst %.cpp, %.o, $(CPP_SOURCES))
OBJ_LIBRARY := $(C_OBJS) $(CPP_OBJS)

# Статическая библиотека
STATIC_LIB = s21_terminal_lib_game.a

# Тестовые файлы
STUBS = tests/curs_set_stub.c
TEST_SOURCE=$(shell find tests -type f -name '*.c' -o -name '*.cpp' )
TEST = $(filter-out tests/curs_set_stub.c, $(TEST_SOURCE))

# Цели
all: clean $(STATIC_LIB) $(TARGET)

# Создание статической библиотеки
$(STATIC_LIB): $(OBJ_LIBRARY)
	ar rcs $(STATIC_LIB) $(OBJ_LIBRARY)
	ranlib $(STATIC_LIB)
# find . -type f \( -name "*.o" \) -exec rm -f {} \;

# Компиляция C файлов
%.o: %.c
	$(CC) -c $< -o $@

# Компиляция C++ файлов
%.o: %.cpp
	$(CXX) -c $< -o $@

# Создание исполняемого файла
$(TARGET): brick_game/main_menu.o $(STATIC_LIB)
	$(CXX) brick_game/main_menu.o -o $(TARGET) $(STATIC_LIB) -lncurses
	
# Тестирование
test: COMPILE_FLAGS := $(CXX) $(TEST_FLAGS)
test: $(STATIC_LIB)
ifeq ($(OS), Darwin)
	$(COMPILE_FLAGS) $(TEST) $(STUBS) -o test.out $(STATIC_LIB) $(LIBS) -lncurses
else
	$(COMPILE_FLAGS) $(TEST) $(STUBS) -o test.out $(STATIC_LIB) $(LINUX) -lncurses
endif
	./test.out

# Отчет о покрытии кода
gcov_report: $(STATIC_LIB) $(TEST)
	mkdir -p gcov_report
ifeq ($(OS), Darwin)	
	gcc $(TEST_FLAGS) $(GCOVFLAGS) $(TEST) $(STUBS) $(SOURCES) -lstdc++ -o gcov_report/report.out $(LIBS)
else
	gcc $(TEST_FLAGS) $(GCOVFLAGS) $(TEST) $(STUBS) $(SOURCES) -lstdc++ -o gcov_report/report.out $(LINUX)
endif
	./gcov_report/report.out	

	lcov -t "Отчет о покрытии gcov для тестов" -o gcov_report/Coverage_Report.info -c -d . \
	--ignore-errors unused \
	--ignore-errors gcov \
	--ignore-errors mismatch --ignore-errors inconsistent \
	--exclude '*/src/tests/*' \
	--exclude '*/src/List/constructors_and_destructor.cpp' \
    --exclude '*/usr/local/include/c++/*' \
    --exclude '*/usr/local/include/gtest/*'

	genhtml -o gcov_report/report/ gcov_report/Coverage_Report.info
	rm -f *.gcno *.gcda *.info gcov_report/report.out *.gcov

ifeq ($(OS), Darwin)
	open gcov_report/report/index-sort-f.html
else
	xdg-open gcov_report/report/index-sort-f.html
endif

show: test
	echo "$(TEST)"
	#valgrind --trace-children=yes --track-origins=yes --track-fds=yes --tool=memcheck --leak-check=full --show-leak-kinds=all --log-file="./report.log" ./test.out
	# cppcheck --enable=all --suppress=missingIncludeSystem $(SOURCES)
	#CK_FORK=no valgrind -s  --trace-children=yes --track-origins=yes --track-fds=yes --tool=memcheck --leak-check=full --show-leak-kinds=all --log-file=RESULT_VALGRIND.txt $(SOURCES)
	valgrind --leak-check=yes --log-file="./report.log" ./test.out  && sync #утечки каждого теста
	#valgrind --leak-check=full --log-file="./report.log" --quiet ./test.out # минимум только ошибки и утечки

# Цель для сборки Qt версии проекта
qt: 
	@echo "===== Building Qt version of the project ====="
	@cd gui/desktop/launcher && qmake -o Makefile launcher.pro
	@cd gui/desktop/launcher && $(MAKE)
	@echo "===== Cleaning up Qt build artifacts except executable ====="
	@cd gui/desktop/launcher && rm -f *.o moc_*.cpp ui_*.h qrc_*.cpp moc_predefs.h
	@cd gui/desktop/launcher && rm -f Makefile

# Ручная очи	стка Qt-сборки
qt_clean:
	@echo "===== Cleaning Qt build files manually ====="
	@cd gui/desktop/launcher && rm -f *.o moc_*.cpp ui_*.h qrc_*.cpp moc_predefs.h Makefile
	@rm -rf gui/desktop/launcher/GameLauncher.app
	@rm -rf gui/desktop/launcher/GameLauncher
	@rm -rf gcov_report
	@echo "===== Cleaning Qt done ====="

# Установка исполняемых файлов (терминал + Qt .app)
define print_progress
    @printf "Прогресс: [%-20s] %d%%\r" "$(shell printf '=%.0s' {1..$(1)}))" "$(shell echo "$(1)*5" | bc)"
    @sleep 0.1
endef

install: uninstall
	@echo "🚀 Начало установки..."
	@echo "1/4 🔧 Сборка терминальной версии..."
	@$(MAKE) -s $(TARGET)
	@echo "2/4 🎨 Сборка Qt версии..."
	@$(MAKE) -s qt
	@echo "3/4 📂 Создание папки bin в домашнем каталоге..."
	@install -d $(HOME)/bin
	@echo "4/4 📦 Копирование файлов..."
	@install -m 755 $(TARGET) $(HOME)/bin
	# Попытка скопировать GameLauncher.app, если он существует (macOS)
	@cp -R gui/desktop/launcher/GameLauncher.app $(HOME)/bin || true
	@cp -R gui/desktop/launcher/GameLauncher $(HOME)/bin || true
	@echo "✅ Установка успешно завершена!"
	@echo "Исполняемые файлы находятся в: $(HOME)/bin"

# Удаление установленного файла
uninstall: clean qt_clean
	rm -f $(HOME)/bin/$(TARGET)
	rm -rf $(HOME)/bin/GameLauncher.app

# Генерация документации
dvi: clean
	$(HOME)/goinfre/homebrew/bin/doxygen Doxyfile
	open docs/html/index.html

# Создание архива с исходными файлами
dist: clean
	tar -czf s21_tetris_snake.tar.gz \
	$(shell find . -type f \( \
	-name "*.qrc" -o \
	-name "*.user" -o \
	-name "*.pro" -o \
	-name "*.png" -o \
	-name "*.jpg" -o \
	-name "*.jpeg" -o \
	-name "*.c" -o \
	-name "*.cpp" -o \
	-name "*.h" -o \
	-name "Makefile" -o \
	-name "Doxyfile" -o \
	-name "custom.css" \)) \
	$(shell find gui/cli/documentation -type f)

# Проверка форматирования кода
check:
	find . -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.h" \) -exec clang-format -i {} \;

# Пересборка
rebuild: clean all

# Очистка
clean:
	@find . -type f \( -name "*.o" -o -name "*.a" -o -name "*.gcno" -o -name "*.gcda" -o -name "*.info" -o -name "*.out" -o -name "*.gcov" -o -name "*.log" \) -exec rm -f {} \;
	@rm -rf ./report
	@rm -rf *.dSYM
	@rm -rf ./docs
	@rm -rf ./s21_tetris_snake.tar.gz
	@rm -rf ./$(TARGET).a
	@rm -rf ./$(TARGET)
	@rm -rf gcov_report
	@echo "*****_clean is done!_*****"

print_sources:
	@echo "Found source files:"
	@echo "$(SOURCES)"



==========================
Итоговое дерево:
./brick_game/common/common.c
./brick_game/common/high_score/high_score.h
./brick_game/common/high_score/load_high_score.c
./brick_game/common/high_score/save_high_score.c
./brick_game/snake/cli_controller/s21_cli_snake.h
./brick_game/snake/cli_controller/snake_controller.cpp
./brick_game/snake/cli_controller/snake_controller.h
./brick_game/snake/cli_controller/snake_main.cpp
./brick_game/snake/model/snake_model.cpp
./brick_game/snake/model/snake_model.h
./brick_game/snake/qt_controller/qt_snake_controller.cpp
./brick_game/snake/qt_controller/qt_snake_controller.h
./brick_game/snake/qt_controller/s21_qt_snake.h
./brick_game/tetris/controller/buttons_reaction.c
./brick_game/tetris/controller/game_over.c
./brick_game/tetris/controller/pause_processing.c
./brick_game/tetris/controller/stub_tetris.c
./brick_game/tetris/model/calculate.c
./brick_game/tetris/model/collision.c
./brick_game/tetris/model/creating_memory_game_objects.c
./brick_game/tetris/model/drop_new_figure.c
./brick_game/tetris/model/free_memory/free_figure_bag.c
./brick_game/tetris/model/free_memory/free_memory_game.c
./brick_game/tetris/model/free_memory/free_tetris_field.c
./brick_game/tetris/model/free_memory/free_tetris_figure.c
./brick_game/tetris/model/free_memory/free_tetris_figures_template.c
./brick_game/tetris/model/move_figure.c
./brick_game/tetris/model/print_high_score.c
./brick_game/tetris/model/processing_figures_after_falling.c
./brick_game/tetris/model/reset_game.c
./brick_game/tetris/model/s21_tetris_cli.h
./brick_game/tetris/model/s21_tetris_game_core.h
./brick_game/tetris/model/speed_from_level.c
./brick_game/tetris/model/templates.c
./brick_game/tetris/qt_controller/qt_tetris_controller.cpp
./brick_game/tetris/qt_controller/qt_tetris_controller.h
./brick_game/tetris/qt_model/qt_tetris_model.cpp
./brick_game/tetris/qt_model/qt_tetris_model.h
./gui/cli/common_gui/welcome_cli/cli_display_welcome_screen.c
./gui/cli/snake/snake_view.cpp
./gui/cli/snake/snake_view.h
./gui/cli/tetris/game_over/cli_game_over.c
./gui/cli/tetris/game_process/cli_create_frame_for_game.c
./gui/cli/tetris/game_process/cli_print_game.c
./gui/cli/tetris/game_process/cli_print_pause.c
./gui/desktop/launcher/launcher.pro
./gui/desktop/launcher/main.cpp
./gui/desktop/launcher/qt_choose_game_view.cpp
./gui/desktop/launcher/qt_choose_game_view.h
./gui/desktop/snake/main_window_snake.cpp
./gui/desktop/snake/main_window_snake.h
./gui/desktop/snake/qt_snake_view.cpp
./gui/desktop/snake/qt_snake_view.h
./gui/desktop/snake/snake_gui.pro
./gui/desktop/tetris/main_window_tetris.cpp
./gui/desktop/tetris/main_window_tetris.h
./gui/desktop/tetris/qt_tetris_view.cpp
./gui/desktop/tetris/qt_tetris_view.h
./gui/desktop/tetris/tetris_gui.pro
./Makefile
